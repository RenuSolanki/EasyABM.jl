var documenterSearchIndex = {"docs":
[{"location":"NNSIsing/#Ising-model-on-a-nearest-neighbor-random-graph","page":"Ising on a nearest neighbor graph","title":"Ising model on a nearest neighbor random graph","text":"","category":"section"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"This is another example including Ising model where the underlying graph is a random nearest neighbor graph on plane. ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"using Pkg, Revise\nPkg.activate(joinpath(@__DIR__, \"../..\"))\nusing EasyABM","category":"page"},{"location":"NNSIsing/#Step-1:-Create-Model","page":"Ising on a nearest neighbor graph","title":"Step 1: Create Model","text":"","category":"section"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"In this model we will work solely with the graph and won't need agents. We initially create an empty graph, and then create our model as follows. ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"graph = dynamic_simple_graph(0)\nmodel = create_graph_model(graph, temp = 2.0, coupl = 2.5, nns = 5)","category":"page"},{"location":"NNSIsing/#Step-2:-Initialise-the-model","page":"Ising on a nearest neighbor graph","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"In the initialiser! function we create a list of n = 500 random points in the plane and fill our graph with n nodes and set the position of ith node to the ith random point. We then link each node to its nns number of nearest neighbors and randomly set each node's color to either :black or :white and set spin value to +1 for :black nodes and -1 for :white nodes. In the init_model! function the argument props_to_record specifies the nodes properties which we want to record during model run. ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"using NearestNeighbors","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"const n=500;","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"function initialiser!(model)\n    vecs = rand(2, n)\n    kdtree = KDTree(vecs,leafsize=4)\n    flush_graph!(model)\n    add_nodes!(n, model, color = :black, spin =1)\n    for i in 1:n \n        model.graph.nodesprops[i].pos = (vecs[1,i], vecs[2,i]) # set position of nodes\n        indices, _ = knn(kdtree, vecs[:,i], model.parameters.nns, true)\n        for j in indices\n            if j!=i\n                create_edge!(i,j, model)\n            end\n        end\n        if rand()<0.5\n            model.graph.nodesprops[i].spin = 1\n            model.graph.nodesprops[i].color = :black\n        else\n            model.graph.nodesprops[i].spin = -1\n            model.graph.nodesprops[i].color = :white\n        end\n    end\nend","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"init_model!(model, initialiser= initialiser!, props_to_record = Dict(\"nodes\"=>[:color, :spin]))","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"draw_graph(model.graph)","category":"page"},{"location":"NNSIsing/#Step-3:-Run-the-model","page":"Ising on a nearest neighbor graph","title":"Step 3: Run the model","text":"","category":"section"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"In this step we implement the step logic of the Ising model in the step_rule! function and run the model for 100 steps. At each step of the simulation we take  100 Monte Carlo steps, where in each Monte Carlo step a node is selected at random and its spin and color values are flipped if the Ising energy condition is satisfied. ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"function step_rule!(model)\n    for i in 1:100\n        random_node = rand(1:n)\n        spin = model.graph.nodesprops[random_node].spin\n        nbr_nodes = neighbor_nodes(random_node, model)\n        de = 0.0\n        for node in nbr_nodes\n            nbr_spin = model.graph.nodesprops[node].spin\n            de += spin*nbr_spin\n        end\n        de = 2*model.parameters.coupl * de\n        if (de < 0) || (rand() < exp(-de/model.parameters.temp))\n            model.graph.nodesprops[random_node].spin = - spin\n            model.graph.nodesprops[random_node].color = spin == -1 ? :black : :white\n        end\n    end\nend","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"run_model!(model, steps = 100, step_rule = step_rule!)","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"animate_sim(model)","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"(Image: png)","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"create_interactive_app(model, initialiser= initialiser!,\n    props_to_record = Dict(\"nodes\"=>[:color, :spin]),\n    step_rule= step_rule!,\n    model_controls=[(:temp, :s, 0.05:0.05:5.0), \n        (:coupl, :s, 0.01:0.1:5.0),\n        (:nns, :s, 2:10)],\n    node_plots = Dict(\"magnetisation\"=> x -> x.spin),\n    frames=100) ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"(Image: png)","category":"page"},{"location":"NNSIsing/#Step-4:-Fetch-Data","page":"Ising on a nearest neighbor graph","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"In this step we fetch the data of average spin of nodes (also called magnetisation) and plot the result as follows.","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"df = get_nodes_avg_props(model, node -> node.spin, labels=[\"magnetisation\"], plot_result = true)","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"(Image: png)","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"","category":"page"},{"location":"tips/","page":"Do's and Don'ts","title":"Do's and Don'ts","text":"warn: Warn\nAvoid modifying any mutable model properties except through using utility functions provided in EasyABM. For example, shuffling the list model.agents may lead to errorneous results. Immutable properties like model.tick must also be not modified as they are only for internal use in EasyABM.","category":"page"},{"location":"tips/","page":"Do's and Don'ts","title":"Do's and Don'ts","text":"tip: Peformance Tips\nAvoid using global variables (its a general tip for Julia users)\nIn EasyABM the types of model properties and agents properties other than position are not declared while defining the model. Therefore, if the user wishes to make code a bit more performant, these properties can be annotated with their types in the step_rule! function.","category":"page"},{"location":"predator_prey/#Predator-prey-model","page":"Predator-prey","title":"Predator-prey model","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"using EasyABM","category":"page"},{"location":"predator_prey/#Step-1:-Create-Agents-and-Model","page":"Predator-prey","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"We create 200 agents all of type sheep to begin with. Our model parameters are ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"max_energy : The maximum energy that an agent (sheep or wolf) can have. \nwolf_birth_rate : Probabality of a wolf agent to reproduce once its energy is greater than max_energy/2.  \nsheep_birth_rate : Probabality of a wolf agent to reproduce once its energy is greater than max_energy/2. \nwolves_kill_ability : The probability of a wolf to kill a neighboring sheep.\ngrass_grow_prob : The probability of one unit of grass growing on a patch at a given timestep.\nmax_grass : Max grass a patch can have.\ninitial_wolf_percent : The percent of agents which are wolf initially. ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"@enum agenttype sheep wolf\nagents = grid_2d_agents(200, pos = Vect(1,1), color = :white, atype = sheep, \n    energy = 10.0, keeps_record_of=[:pos, :energy ])\nmodel = create_2d_model(agents, size = (20,20), \n    agents_type = Mortal, # agents are mortal, can take birth or die\n    space_type = NPeriodic, # nonperiodic space\n    max_energy = 50, \n    wolf_birth_rate = 0.01,\n    sheep_birth_rate = 0.1,\n    wolves_kill_ability = 0.2,\n    max_grass = 5,\n    initial_wolf_percent = 0.2,\n    grass_grow_prob = 0.2)","category":"page"},{"location":"predator_prey/#Step-2:-Initialise-the-model","page":"Predator-prey","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"In the second step we initialise the agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we randomly set amount of grass and accordingly color of each patch. We also set a fraction initial_wolf_percent of agents to be of type wolf. We set color of sheeps to white and that of wolves to black. We also randomly set the energy and positions of agents. In the init_model! function through argument props_to_record we tell EasyABM to record the color property of patches during model run. ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"function initialiser!(model)\n    max_grass = model.parameters.max_grass\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            grass = rand(1:max_grass)\n            model.patches[i,j].grass = grass\n            hf = Int(ceil(max_grass/2))\n            model.patches[i,j].color = grass > hf ? :green : (grass > 0 ? :blue : :grey)\n        end\n    end\n    for agent in model.agents\n        if rand()< model.parameters.initial_wolf_percent \n            agent.atype = wolf\n            agent.color = :black\n        else\n            agent.atype = sheep\n            agent.color = :white\n        end\n        agent.energy = rand(1:model.parameters.max_energy)+0.0\n        agent.pos = Vect(rand(1:model.size[1]), rand(1:model.size[2]))\n    end\n            \nend\n\ninit_model!(model, initialiser = initialiser!, props_to_record = Dict(\"patches\"=>[:color]))","category":"page"},{"location":"predator_prey/#Step-3:-Run-the-model","page":"Predator-prey","title":"Step 3: Run the model","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"In this step we implement the step logic of the predator prey model in the step_rule! function and run the model for 100 steps. ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"function change_pos!(agent)\n    dx = rand(-1:1)\n    dy = rand(-1:1)\n    agent.pos += Vect(dx, dy)\nend\n\nfunction reproduce!(agent, model)\n    new_agent = create_similar(agent)\n    agent.energy = agent.energy/2\n    new_agent.energy = agent.energy\n    add_agent!(new_agent, model)\nend\n\nfunction eat_sheep!(wolf, sheep, model)\n    kill_agent!(sheep, model) \n    wolf.energy+=1\nend\n\n\nfunction act_asa_wolf!(agent, model)\n    if !(is_alive(agent))\n        return\n    end\n    energy = agent.energy\n    if energy > 0.5*model.parameters.max_energy\n        if rand()<model.parameters.wolf_birth_rate\n            reproduce!(agent, model)\n        end\n    elseif energy > 0 \n        nbrs = collect(grid_neighbors(agent, model, 1))\n        n = length(nbrs)\n        if n>0\n            nbr = nbrs[rand(1:n)]\n            if (nbr.atype == sheep)&&(is_alive(nbr))\n                ability = model.parameters.wolves_kill_ability\n                (rand()<ability)&&(eat_sheep!(agent, nbr, model))\n            end\n        end\n        change_pos!(agent)\n    else\n        kill_agent!(agent, model)\n    end\nend\n\nfunction act_asa_sheep!(agent, model)\n    if !(is_alive(agent))\n        return\n    end\n    energy = agent.energy\n    if energy >0.5* model.parameters.max_energy\n        if rand()<model.parameters.sheep_birth_rate\n            reproduce!(agent, model)\n        end\n        change_pos!(agent)\n    elseif energy > 0 \n        patch = get_grid_loc(agent, model)\n        grass = model.patches[patch...].grass\n        if grass>0\n            model.patches[patch...].grass-=1\n            agent.energy +=1\n        end\n        change_pos!(agent)\n    else\n        kill_agent!(agent, model)\n    end\nend\n\n\n\nfunction step_rule!(model)\n    if model.max_id>800 # use some upper bound on max agents to avoid system hang\n        return\n    end\n    for agent in model.agents\n        if agent.atype == wolf\n            act_asa_wolf!(agent,model)\n        end\n        if agent.atype == sheep\n            act_asa_sheep!(agent, model)\n        end\n    end\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            patch = model.patches[i,j]\n            grass = patch.grass\n            max_grass = model.parameters.max_grass \n            if grass < max_grass\n                if rand()<model.parameters.grass_grow_prob\n                    patch.grass+=1\n                    hf = Int(ceil(max_grass/2))\n                    patch.color = grass > hf ? :green : (grass > 0 ? :yellow : :grey)\n                end\n            end\n        end\n    end\nend\n\nrun_model!(model, steps=100, step_rule = step_rule! )","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"animate_sim(model, show_grid=true)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"(Image: png)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[\n        (:wolf_birth_rate, :s, 0:0.01:1.0),\n        (:sheep_birth_rate, :s, 0.01:0.01:1.0),\n        (:initial_wolf_percent, :s, 0.01:0.01:0.9),\n        (:wolves_kill_ability, :s, 0.01:0.01:1.0),\n        (:grass_grow_prob, :s, 0.01:0.01:0.5)\n        ], \n    agent_plots=Dict(\"sheep\"=> agent-> agent.atype == sheep ? 1 : 0, \n        \"wolf\"=> agent-> agent.atype == wolf ? 1 : 0),\n    frames=200, show_grid=true)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"(Image: png)","category":"page"},{"location":"predator_prey/#Step-4:-Fetch-Data","page":"Predator-prey","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"We can fetch the number of wolves and sheeps at each time step as follows. ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"df = get_nums_agents(model, agent-> agent.atype == sheep, \n    agent->agent.atype == wolf, labels=[\"Sheep\", \"Wolf\"], \n    plot_result = true)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"(Image: png)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"schelling/#Schelling-segregation-model","page":"Schellings Segregation model","title":"Schelling segregation model","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"using EasyABM","category":"page"},{"location":"schelling/#Step-1:-Create-Agents-and-Model","page":"Schellings Segregation model","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"Lets create 200 agents with properties pos, mood and color. The keeps_record_of argument is list of properties that the agent will record during time evolution. The min_alike property of the model which specifies the minimum number of alike neighbors for an agent to be happy, is set to be 4. ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"@enum agentsfeeling happy sad\nagents = grid_2d_agents(200, pos = Vect(1,1), color = :green, mood = happy, keeps_record_of=[:pos, :mood])\nmodel = create_2d_model(agents, agents_type = Static, space_type=NPeriodic, size = (20,20), min_alike = 4)","category":"page"},{"location":"schelling/#Step-2:-Initialise-the-model","page":"Schellings Segregation model","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"In the second step we initialise the agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we randomly set agents color to be either :red or :green and set their positions randomly such that there is not more than one agent on each patch. Then we set the mood property of each agent to be happy or sad depending upon the number of alike agents in neighborhood. ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"function initialiser!(model)\n    min_alike = model.parameters.min_alike\n    for agent in model.agents\n        agent.color = [:red, :green][rand(1:2)]\n        x,y = random_empty_patch(model)   \n        agent.pos = Vect(x,y)\n    end    \n    for agent in model.agents\n        nbrs = grid_neighbors(agent, model, 1)\n        num_alike = 0\n        for nbr in nbrs\n            if nbr.color == agent.color\n                num_alike += 1\n            end\n        end\n        if num_alike < min_alike\n            agent.mood = sad\n        end\n    end\nend\n\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"schelling/#Step-3:-Run-the-model","page":"Schellings Segregation model","title":"Step 3: Run the model","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"In this step we implement the step logic of the Schelling's model in the step_rule! function and run the model for 200 steps. ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"function step_rule!(model)\n    min_alike = model.parameters.min_alike\n    for agent in model.agents\n        count_alike = 0\n        for nbr in grid_neighbors(agent, model,1)\n            if agent.color == nbr.color\n                count_alike += 1\n            end\n        end\n        if count_alike ≥ min_alike\n            agent.mood = happy\n        else\n            agent.mood = sad\n            x,y = random_empty_patch(model) \n            agent.pos = Vect(x,y)\n        end\n    end\n    return\nend\n\nrun_model!(model, steps=200, step_rule = step_rule! )","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"animate_sim(model,agent_plots=Dict(\"happy\"=> agent-> agent.mood == happy, \"sad\"=> agent-> agent.mood == sad), show_grid=true)","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"(Image: png)","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule=step_rule!,\n    model_controls=[(:min_alike, :s, 1:8)], \n    agent_plots=Dict(\n        \"happy\"=> agent-> agent.mood == happy, \n        \"sad\"=> agent-> agent.mood == sad),\n    frames=200) ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"(Image: png)","category":"page"},{"location":"schelling/#Step-4:-Fetch-Data","page":"Schellings Segregation model","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"In this step we fetch data of number of happy and sad agents at each time step as a dataframe using following line of code. ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"df = get_nums_agents(model, agent-> agent.mood == happy, agent-> agent.mood == sad,labels=[\"happy\",\"sad\"], plot_result=true)","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"(Image: png)","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"schelling/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"nearest_neighbor_graph/#Nearest-neighbor-graph-generator","page":"Nearest Neighbor Graph","title":"Nearest neighbor graph generator","text":"","category":"section"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"We include the present model as an example of dynamic graphs in EasyABM.","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"using EasyABM","category":"page"},{"location":"nearest_neighbor_graph/#Step-1:-Create-Model","page":"Nearest Neighbor Graph","title":"Step 1: Create Model","text":"","category":"section"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"In this model we will work solely with the graph and won't require agents. We create a dynamic graph of n=500 vertices (and no edges) and create a model with this graph as base space. The model parameter nns is the number of nearest neighbors that each node will have edges with. ","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"n=500\ngraph = dynamic_simple_graph(n);  \nmodel = create_graph_model(graph, nns=10)","category":"page"},{"location":"nearest_neighbor_graph/#Step-2:-Initialise-the-model","page":"Nearest Neighbor Graph","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"In this model we use NearestNeighbors.jl package to produce a kdtree of points which will be used to get nearest neighbors in the step rule. We create a random 2xn matrix and initialise the positions of nodes with these vectors. ","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"vecs = rand(2, n);\n\nfunction initialiser!(model)\n    for i in 1:n\n        model.graph.nodesprops[i].pos = (vecs[1,i], vecs[2,i])\n    end\nend\n\ninit_model!(model, initialiser= initialiser!)","category":"page"},{"location":"nearest_neighbor_graph/#Step-3:-Run-the-model","page":"Nearest Neighbor Graph","title":"Step 3: Run the model","text":"","category":"section"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"In the step_rule! function we need to compute nearest neighbors of points for which we make use of NearestNeighbors.jl package.","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"using NearestNeighbors\nkdtree = KDTree(vecs,leafsize=4)\n\nfunction step_rule!(model)\n    if model.tick <=n\n        i = model.tick\n        indices, _ = knn(kdtree, vecs[:,i], model.parameters.nns, true)\n        for j in indices\n            if j!=i\n                create_edge!(i,j, model)\n            end\n        end\n    end  \nend\n\nrun_model!(model, steps=n, step_rule = step_rule! )","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"animate_sim(model)","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"(Image: png)","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"create_interactive_app(model, initialiser = initialiser!,\n    step_rule = step_rule!,\n    model_controls = [(:nns, :s, 1:20)],\n    frames = n\n)","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"(Image: png)","category":"page"},{"location":"nearest_neighbor_graph/#Step-4:-Fetch-Data","page":"Nearest Neighbor Graph","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"In the present model we didn't record any data, however, since the model involved a dynamic graph the number of edges (and nodes) at each time step were recorded by default by EasyABM. We can get the data of number of edges at each time step as follows","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"df = get_nums_edges(model, edge-> true, labels=[\"num edges\"], plot_result = true)","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"(Image: png)","category":"page"},{"location":"SIR/#SIR-model","page":"SIR model","title":"SIR model","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In the agent-based modeling approach an epidemiological model, like SIR model can have a large number of parameters depending upon the requirements. Below we will implement a basic SIR model in EasyABM.","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"using EasyABM","category":"page"},{"location":"SIR/#Step-1:-Create-Agents-and-Model","page":"SIR model","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In our SIR model there will be four type of agents - agentS (susceptible), agentI (infectious), agentR (recovered) and agentD (dead). We assume that the recovered agents become immune and do not get infected again. We create 500 2d agents all of type agentS (later in the initilisation step will set the type of some agents to be agentI). The not_well_since property of an agent is the time since the agent got infected. Our model has parameters initially_sick (number of agents initially sick), sickness_duration (duration of sickness), infection_prob (probability of infection when an infected agent comes in contact with a susceptible agent) and death_prob (the probability of death from infection). ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"\n@enum AgentType begin\n    agentS=1\n    agentI=2\n    agentR=3\n    agentD=4\nend\n\nagents = grid_2d_agents(500, pos = Vect(1,1), color=:green, \n        atype = agentS, not_well_since = 0, \n        keeps_record_of = [:atype, :color, :pos]);\n\nmodel = create_2d_model(agents, size=(50,50), \n        agents_type = Static, # agents don't take birth or die\n        space_type = Periodic, initially_sick = 10, \n        sickness_duration = 21, infection_prob = 0.8, \n        death_prob=0.05);","category":"page"},{"location":"SIR/#Step-2:-Initialise-the-model","page":"SIR model","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In the second step we initialise the agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we set first initially_sick number of agents to be of type agentI and set their color to :red. All other agents are set to be of type agentS with color :green. We also set each agents position at the center of a randomly selected patch.  ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"function initialiser!(model)\n    for (i,agent) in enumerate(model.agents)\n        if i<=model.parameters.initially_sick\n            agent.atype = agentI\n            agent.color = :red\n        else \n            agent.atype = agentS\n            agent.color = :green\n        end\n        agent.not_well_since = 0 \n        x = rand(1:model.size[1])\n        y = rand(1:model.size[2])\n        agent.pos = Vect(x, y) # center of a random patch\n    end\nend\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"SIR/#Step-3:-Run-the-model","page":"SIR model","title":"Step 3: Run the model","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In this step we implement the step logic of the SIR model in the step_rule! function and run the model for 100 steps. ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"function die_or_recover(agent, death_prob)\n    if rand()<death_prob\n        agent.atype = agentD\n        agent.color = :black\n    else\n        agent.atype = agentR\n        agent.color = :yellow\n    end\n    agent.not_well_since = 0 \nend\n\nfunction infect_neighbors(agent, nbrs, infection_prob)\n    for nbr in nbrs\n        if (nbr.atype ==agentS) && (rand()< infection_prob)\n            nbr.atype = agentI\n            nbr.not_well_since = 0\n            nbr.color = :red\n        end\n    end\nend\n\nfunction change_position(agent)\n    dx =rand(-1:1)\n    dy =rand(-1:1)\n    agent.pos += Vect(dx,dy)\nend\n\nfunction step_rule!(model)\n    parameters = model.parameters\n    for agent in model.agents\n        nbrs = grid_neighbors(agent, model, 1) #immediate neighbors on grid\n        if agent.atype == agentI\n             agent.not_well_since +=1\n            if agent.not_well_since > parameters.sickness_duration\n                die_or_recover(agent, parameters.death_prob)\n            elseif agent.not_well_since>1\n                infect_neighbors(agent, nbrs, parameters.infection_prob)\n            end   \n        end\n        if agent.atype !=agentD\n            change_position(agent)\n        end   \n    end\nend\n\n\nrun_model!(model, steps=100, step_rule = step_rule! )","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"animate_sim(model)","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"(Image: png)","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[(:initially_sick, :s, 1:500), \n        (:sickness_duration, :s, 5:25),\n        (:infection_prob, :s, 0.01:0.01:1.0),\n        (:death_prob, :s, 0.01:0.01:0.1)\n        ],\n    agent_plots = Dict(\"Susceptible\"=> ag -> ag.atype == agentS ? 1 : 0, \n        \"Infected\" => ag -> ag.atype == agentI ? 1 : 0,\n        \"Recovered\" => ag -> ag.atype == agentR ? 1 : 0\n        ),\n    frames=70)  ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"(Image: png)","category":"page"},{"location":"SIR/#Step-4:-Fetch-Data","page":"SIR model","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"The following line of code fetches data of average number of susceptible, infectious and recovered agents.  The function get_agents_avg_props averages over all agents the values returned by functions sent to it as arguments. ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"df = get_agents_avg_props(model, \n    ag -> ag.atype == agentS ? 1 : 0,\n    ag -> ag.atype == agentI ? 1 : 0, \n    ag -> ag.atype == agentR ? 1 : 0, \n    labels = [\"Susceptible\", \"Infected\", \"Recovered\"],\n    plot_result = true\n)","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"(Image: png)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"EasyABM provides following functions for agent based simulations. ","category":"page"},{"location":"api/#Functions-for-creating-agents","page":"API","title":"Functions for creating agents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"con_2d_agent\ncon_2d_agents\ngrid_2d_agent\ngrid_2d_agents\ncon_3d_agent\ncon_3d_agents\ngrid_3d_agent\ngrid_3d_agents\ngraph_agent\ngraph_agents\ncreate_similar","category":"page"},{"location":"api/#EasyABM.con_2d_agent","page":"API","title":"EasyABM.con_2d_agent","text":"con_2d_agent(; pos, space_type, kwargs...) -> EasyABM.Agent2D{Symbol, Any, Float64, Periodic}\n\n\nCreates a single 2d agent with properties specified as keyword arguments.  Following property names are reserved for some specific agent properties      - pos : position     - vel : velocity     - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keepsrecordof : list of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.con_2d_agents","page":"API","title":"EasyABM.con_2d_agents","text":"con_2d_agents(n::Int64; pos, space_type, kwargs...) -> Vector{EasyABM.Agent2D{Symbol, Any, Float64, Periodic}}\n\n\nCreates a list of n 2d agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.grid_2d_agent","page":"API","title":"EasyABM.grid_2d_agent","text":"grid_2d_agent(; pos, space_type, kwargs...) -> EasyABM.Agent2D{Symbol, Any, Int64, Periodic}\n\n\nCreates a single 2d agent with properties specified as keyword arguments.  Following property names are reserved for some specific agent properties      - pos : position     - vel : velocity     - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keepsrecordof : list of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.grid_2d_agents","page":"API","title":"EasyABM.grid_2d_agents","text":"grid_2d_agents(n::Int64; pos, space_type, kwargs...) -> Vector{EasyABM.Agent2D{Symbol, Any, Int64, Periodic}}\n\n\nCreates a list of n 2d agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.con_3d_agent","page":"API","title":"EasyABM.con_3d_agent","text":"con_3d_agent(; pos, space_type, kwargs...) -> EasyABM.Agent3D{Symbol, Any, Float64, Periodic}\n\n\nCreates a single 3d agent with properties specified as keyword arguments. Following property names are reserved for some specific agent properties      - pos : position     - vel : velocity     - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keepsrecordof : list of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.con_3d_agents","page":"API","title":"EasyABM.con_3d_agents","text":"con_3d_agents(n::Int64; pos, space_type, kwargs...) -> Vector{EasyABM.Agent3D{Symbol, Any, Float64, Periodic}}\n\n\nCreates a list of n 3d agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.grid_3d_agent","page":"API","title":"EasyABM.grid_3d_agent","text":"grid_3d_agent(; pos, space_type, kwargs...) -> EasyABM.Agent3D{Symbol, Any, Int64, Periodic}\n\n\nCreates a single 3d agent with properties specified as keyword arguments.  Following property names are reserved for some specific agent properties      - pos : position     - vel : velocity     - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keepsrecordof : list of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.grid_3d_agents","page":"API","title":"EasyABM.grid_3d_agents","text":"grid_3d_agents(n::Int64; pos, space_type, kwargs...) -> Vector{EasyABM.Agent3D{Symbol, Any, Int64, Periodic}}\n\n\nCreates a list of n 2d agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.graph_agent","page":"API","title":"EasyABM.graph_agent","text":"graph_agent(; node, graph_mort_type, kwargs...) -> EasyABM.GraphAgent{Symbol, Any, Static}\n\n\nCreates a single graph agent with properties specified as keyword arguments. Following property names are reserved for some specific agent properties      - node : node where the agent is located on the graph.      - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keepsrecordof : list of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.graph_agents","page":"API","title":"EasyABM.graph_agents","text":"graph_agents(n::Int64; node, graph_mort_type, kwargs...) -> Vector{EasyABM.GraphAgent{Symbol, Any, Static}}\n\n\nCreates a list of n graph agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_similar","page":"API","title":"EasyABM.create_similar","text":"create_similar(agent::EasyABM.Agent2D{Symbol, Any, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}, n::Int64) -> Vector\n\n\nReturns a list of n 2d agents all having same properties as agent.  \n\n\n\n\n\ncreate_similar(agent::EasyABM.Agent2D{Symbol, Any, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}) -> EasyABM.Agent2D{Symbol, Any}\n\n\nReturns an agent with same properties as given agent. \n\n\n\n\n\ncreate_similar(agent::EasyABM.GraphAgent{Symbol, Any, S<:EasyABM.MType}, n::Int64) -> Vector\n\n\nReturns a list of n 2d agents all having same properties as agent.  \n\n\n\n\n\ncreate_similar(agent::EasyABM.GraphAgent{Symbol, Any, S<:EasyABM.MType}) -> EasyABM.GraphAgent{Symbol, Any}\n\n\nReturns a list of n 2d agents all having same properties as agent.  \n\n\n\n\n\ncreate_similar(agent::EasyABM.Agent3D{Symbol, Any, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}, n::Int64) -> Vector\n\n\nReturns a list of n 2d agents all having same properties as agent.  \n\n\n\n\n\ncreate_similar(agent::EasyABM.Agent3D{Symbol, Any, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}) -> EasyABM.Agent3D{Symbol, Any}\n\n\nReturns an agent with same properties as given agent. \n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-defining-model","page":"API","title":"Functions for defining model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"create_2d_model\ncreate_3d_model\ncreate_graph_model","category":"page"},{"location":"api/#EasyABM.create_2d_model","page":"API","title":"EasyABM.create_2d_model","text":"create_2d_model(agents::Array{EasyABM.Agent2D{Symbol, Any, S<:Union{Int64, AbstractFloat}, A<:EasyABM.SType}, 1}; graphics, agents_type, size, random_positions, space_type, kwargs...) -> EasyABM.SpaceModel2D{Static, _A, Periodic} where _A<:Union{Int64, AbstractFloat}\n\n\nCreates a 2d model with \n\nagents : list of agents.\ngraphics : if true, properties of shape, color, orientation will be assigned to each agent by default, if not already assigned by the user.\nfix_agent_num : Set it to true if agents do not die and new agents are not born during simulation.\nsize : A tuple (dimx, dimy) which tells the number of blocks the space is to be divided into along x and y directions. An agent can take\n\npositions from 0 to dimx in x-direction and 0 to dimy in y direction. The agents can move continuously or  in discrete steps depending upon how user implements the step rule (unless the agents are of grid type which can only move in dicrete steps).  Each unit block of space is called a patch which like agents can be assigned  its own properties.  \n\nperiodic: Ifperiodic` is true the grid space will be periodic in both x and y directions. If set to false, agents can not be assigned position outside the \n\nspace boundaries\n\nrandom_positions : If this property is true, each agent, will be assigned a random position. \nkwargs` : Keyword argments used as model parameters. \n\n\n\n\n\ncreate_2d_model(; graphics, size, random_positions, space_type, kwargs...) -> EasyABM.SpaceModel2D{_A, Float64} where _A\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_3d_model","page":"API","title":"EasyABM.create_3d_model","text":"create_3d_model(agents::Array{EasyABM.Agent3D{Symbol, Any, S<:Union{Int64, AbstractFloat}, A<:EasyABM.SType}, 1}; graphics, agents_type, size, random_positions, space_type, kwargs...) -> EasyABM.SpaceModel3D{Static, _A, Periodic} where _A<:Union{Int64, AbstractFloat}\n\n\nCreates a 3d model with \n\nagents : list of agents.\ngraphics : if true, properties of shape, color, orientation will be assigned to each agent by default, if not already assigned by the user.\nfix_agent_num : Set it to true if agents do not die and new agents are not born during simulation.\nsize : A tuple (dimx, dimy, dimz) which tells the number of blocks the space is to be divided into along x, y and z directions. An agent can take\n\npositions from 0 to dimx in x-direction, 0 to dimy in y direction and 0 to dimz in z direction. The agents can move continuously or  in discrete steps depending upon how user implements the step rule (unless the agents are of grid type which can only move in dicrete steps).  Each unit block of space is called a patch which like agents can be assigned  its own properties.  \n\nperiodic: Ifperiodic` is true the grid space will be periodic in x, y and z directions. If set to false, agents can not be assigned position outside the \n\nspace boundaries\n\nrandom_positions : If this property is true, each agent, will be assigned a random position. \nkwargs` : Keyword argments used as model parameters. \n\n\n\n\n\ncreate_3d_model(; graphics, size, random_positions, space_type, kwargs...) -> EasyABM.SpaceModel3D{_A, Float64} where _A\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_graph_model","page":"API","title":"EasyABM.create_graph_model","text":"create_graph_model(agents::Array{EasyABM.GraphAgent{Symbol, Any, A<:EasyABM.MType}, 1}, graph::EasyABM.AbstractPropGraph{S<:EasyABM.MType, G<:EasyABM.GType}; agents_type, decorated_edges, graphics, random_positions, kwargs...) -> EasyABM.GraphModel{_A, Static} where _A<:EasyABM.MType\n\n\nCreates a model with \n\nagents : list of agents.\ngraph  : A graph coverted to EasyABM graph from Graph.jl or created with EasyABM graph functionality.\ngraphics : if true properties of pos, shape, color, orientation will be assigned to each agent by default, if not already assigned by user.\nfix_agent_num : Set it to true if agents do not die and new agents are not born during simulation. \ndecorated_edges : Set it to true if edges are to be assigned weights or any other properties.\nrandom_positions : If this property is true, each agent will be assigned a random node on the graph. \nkwargs : Keyword argments used as model parameters. \n\n\n\n\n\ncreate_graph_model(graph::EasyABM.AbstractPropGraph{S<:EasyABM.MType, G<:EasyABM.GType}; decorated_edges, graphics, random_positions, kwargs...) -> EasyABM.GraphModel\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-initialising,-running-and-visualising","page":"API","title":"Functions for initialising, running and visualising","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"init_model!\nrun_model!\nrun_model_epochs!\nanimate_sim\ncreate_interactive_app","category":"page"},{"location":"api/#EasyABM.init_model!","page":"API","title":"EasyABM.init_model!","text":"init_model!(model::EasyABM.SpaceModel2D; initialiser, props_to_record, keep_deads_data)\n\n\nInitiates the simulation with a user defined initialiser function which takes the model as its only argument.  Model parameters along with agent properties can be set (or modified) from within a user defined function and then sending it as initialiser argument in init_model!. The properties of  agents, patches and model that are to be recorded during time evolution can be specified through the dictionary argument props_to_record.  List of agent properties to be recorded are specified with key \"agents\" and value the list of property names as symbols. If a nonempty list of  agents properties is specified, it will replace the keeps_record_of list of each agent. Properties of patches and model are similarly specified with keys \"patches\" and \"model\" respectively.\n\n\n\n\n\ninit_model!(model::EasyABM.SpaceModel3D; initialiser, props_to_record, keep_deads_data)\n\n\nInitiates the simulation with a user defined initialiser function which takes the model as its only argument.  Model parameters along with agent properties can be set (or modified) from within a user defined function and then sending it as initialiser  argument in init_model!. The properties of agents, patches and model that are to be recorded during time evolution can be specified through  the dictionary argument props_to_record. List of agent properties to be recorded are specified with key \"agents\" and value the list of property  names as symbols. If a nonempty list of agents properties is specified, it will replace the keeps_record_of list of each agent. Properties of  patches and model are similarly specified with keys \"patches\" and \"model\" respectively.\n\n\n\n\n\ninit_model!(model::EasyABM.GraphModel; initialiser, props_to_record, keep_deads_data)\n\n\nInitiates the simulation with a user defined initialiser function which takes the model as its only argument.  Model parameters along with agent and graph properties can be set (or modified) from within a user defined function and then sending  it as initialiser argument in init_model!. The properties of  agents, nodes, edges and the model that are to be recorded during time evolution can be specified through the dictionary argument props_to_record.  List of agent properties to be recorded are specified with key \"agents\" and value the list of property names as symbols. If a nonempty list of  agents properties is specified, it will replace the keeps_record_of list of each agent. Properties of nodes, edges and model are similarly specified with keys \"nodes\", \"edges\" and \"model\" respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.run_model!","page":"API","title":"EasyABM.run_model!","text":"run_model!(model::EasyABM.SpaceModel2D; steps, step_rule)\n\n\nRuns the simulation for steps number of steps.\n\n\n\n\n\nrun_model!(model::EasyABM.SpaceModel3D; steps, step_rule)\n\n\nRuns the simulation for steps number of steps.\n\n\n\n\n\nrun_model!(model::EasyABM.GraphModel; steps, step_rule)\n\n\nRuns the simulation for steps number of steps.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.run_model_epochs!","page":"API","title":"EasyABM.run_model_epochs!","text":"run_model_epochs!(model::EasyABM.SpaceModel2D; steps_per_epoch, num_epochs, step_rule, save_to_folder)\n\n\nRuns the simulation for num_epochs number of epochs where each epoch consists of steps_per_epoch number of steps. The model is saved as .jld2 file and the model.tick is reset to 1 at the end of each epoch.\n\n\n\n\n\nrun_model_epochs!(model::EasyABM.SpaceModel3D; steps_per_epoch, num_epochs, step_rule, save_to_folder)\n\n\nRuns the simulation for num_epochs number of epochs where each epoch consists of steps_per_epoch number of steps. The model is saved as .jld2 file and the model.tick is reset to 1 at the end of each epoch.\n\n\n\n\n\nrun_model_epochs!(model::EasyABM.GraphModel; steps_per_epoch, num_epochs, step_rule, save_to_folder)\n\n\nRuns the simulation for num_epochs number of epochs where each epoch consists of steps_per_epoch number of steps. The model is saved as .jld2 file and the model.tick is reset to 1 at the end of each epoch.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.animate_sim","page":"API","title":"EasyABM.animate_sim","text":"animate_sim(model::EasyABM.SpaceModel2D) -> Widgets.Widget{:default, Any}\nanimate_sim(model::EasyABM.SpaceModel2D, frames::Int64; agent_plots, patch_plots, model_plots, plots_only, path, show_grid, backend, tail) -> Widgets.Widget{:default, Any}\n\n\nCreates an animation from the data collected during model run.\n\n\n\n\n\nanimate_sim(model::EasyABM.SpaceModel3D) -> Union{Nothing, MeshCat.DisplayedVisualizer}\nanimate_sim(model::EasyABM.SpaceModel3D, frames::Int64; show_grid, tail) -> Union{Nothing, MeshCat.DisplayedVisualizer}\n\n\nCreates a 3d animation from the data collected during the model run.\n\n\n\n\n\nanimate_sim(model::EasyABM.GraphModel) -> Widgets.Widget{:default, Any}\nanimate_sim(model::EasyABM.GraphModel, frames::Int64; agent_plots, node_plots, model_plots, plots_only, path, show_graph, backend) -> Widgets.Widget{:default, Any}\n\n\nCreates an animation from the data collected during model run.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_interactive_app","page":"API","title":"EasyABM.create_interactive_app","text":"create_interactive_app(inmodel::EasyABM.SpaceModel2D; initialiser, props_to_record, step_rule, agent_controls, model_controls, agent_plots, patch_plots, model_plots, plots_only, path, frames, show_grid, backend, tail) -> Widgets.Widget{:default, Any}\n\n\nCreates an interactive app for the model.\n\n\n\n\n\ncreate_interactive_app(inmodel::EasyABM.SpaceModel3D; initialiser, props_to_record, step_rule, agent_controls, model_controls, agent_plots, patch_plots, model_plots, plots_only, frames, show_grid, tail) -> Widgets.Widget{:default, Any}\n\n\nCreates an interactive app for the model.\n\n\n\n\n\ncreate_interactive_app(inmodel::EasyABM.GraphModel; initialiser, props_to_record, step_rule, agent_controls, model_controls, agent_plots, node_plots, model_plots, plots_only, path, frames, show_graph, backend) -> Widgets.Widget{:default, Any}\n\n\nCreates an interactive app for the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-accessing,-saving-and-retrieving-data.","page":"API","title":"Functions for accessing, saving and retrieving data.","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_agent_data \nget_patch_data \nget_node_data\nget_edge_data \nget_model_data \nlatest_propvals\npropnames\nget_nums_agents \nget_nums_patches\nget_nums_nodes \nget_nums_edges\nget_agents_avg_props\nget_patches_avg_props\nget_nodes_avg_props\nget_edges_avg_props\nsave_model\nopen_saved_model","category":"page"},{"location":"api/#EasyABM.get_agent_data","page":"API","title":"EasyABM.get_agent_data","text":"get_agent_data(agent::EasyABM.AbstractAgent, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, Mortal}, EasyABM.AbstractSpaceModel{Mortal}}) -> NamedTuple{(:birthtime, :deathtime, :record), Tuple{Int64, Int64, DataFrames.DataFrame}}\nget_agent_data(agent::EasyABM.AbstractAgent, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, Mortal}, EasyABM.AbstractSpaceModel{Mortal}}, props) -> NamedTuple{(:birthtime, :deathtime, :record), Tuple{Int64, Int64, DataFrames.DataFrame}}\n\n\n\n\n\n\nget_agent_data(agent::EasyABM.AbstractAgent, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, Static}, EasyABM.AbstractSpaceModel{Static}}) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\nget_agent_data(agent::EasyABM.AbstractAgent, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, Static}, EasyABM.AbstractSpaceModel{Static}}, props) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_patch_data","page":"API","title":"EasyABM.get_patch_data","text":"get_patch_data(patch, model::EasyABM.AbstractSpaceModel) -> Union{Nothing, NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}}\nget_patch_data(patch, model::EasyABM.AbstractSpaceModel, props) -> Union{Nothing, NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_node_data","page":"API","title":"EasyABM.get_node_data","text":"get_node_data(node::Int64, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}) -> NamedTuple{(:birthtime, :deathtime, :record), Tuple{Int64, Int64, DataFrames.DataFrame}}\nget_node_data(node::Int64, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}, props) -> NamedTuple{(:birthtime, :deathtime, :record), Tuple{Int64, Int64, DataFrames.DataFrame}}\n\n\n\n\n\n\nget_node_data(node::Int64, model::Union{EasyABM.GraphModel{Static, Mortal}, EasyABM.GraphModel{Static, Static}}) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\nget_node_data(node::Int64, model::Union{EasyABM.GraphModel{Static, Mortal}, EasyABM.GraphModel{Static, Static}}, props) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_edge_data","page":"API","title":"EasyABM.get_edge_data","text":"get_edge_data(i::Int64, j::Int64, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}) -> NamedTuple{(:birth_death_times, :record), Tuple{Vector{Tuple{Int64, Int64}}, DataFrames.DataFrame}}\nget_edge_data(i::Int64, j::Int64, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}, props) -> NamedTuple{(:birth_death_times, :record), Tuple{Vector{Tuple{Int64, Int64}}, DataFrames.DataFrame}}\n\n\n\n\n\n\nget_edge_data(edge, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}) -> NamedTuple{(:birth_death_times, :record), Tuple{Vector{Tuple{Int64, Int64}}, DataFrames.DataFrame}}\nget_edge_data(edge, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}, props) -> NamedTuple{(:birth_death_times, :record), Tuple{Vector{Tuple{Int64, Int64}}, DataFrames.DataFrame}}\n\n\n\n\n\n\nget_edge_data(i::Int64, j::Int64, model::Union{EasyABM.GraphModel{Static, Mortal}, EasyABM.GraphModel{Static, Static}})\nget_edge_data(i::Int64, j::Int64, model::Union{EasyABM.GraphModel{Static, Mortal}, EasyABM.GraphModel{Static, Static}}, props)\n\n\n\n\n\n\nget_edge_data(edge, model::Union{EasyABM.GraphModel{Static, Mortal}, EasyABM.GraphModel{Static, Static}})\nget_edge_data(edge, model::Union{EasyABM.GraphModel{Static, Mortal}, EasyABM.GraphModel{Static, Static}}, props)\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_model_data","page":"API","title":"EasyABM.get_model_data","text":"get_model_data(model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractSpaceModel}) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\nget_model_data(model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractSpaceModel}, props) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.latest_propvals","page":"API","title":"EasyABM.latest_propvals","text":"latest_propvals(obj::EasyABM.AbstractPropDict, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(agent::EasyABM.AbstractPropDict, model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractSpaceModel}, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(patch, model::EasyABM.AbstractSpaceModel, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(node::Int64, model::EasyABM.GraphModel, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(i::Int64, j::Int64, model::EasyABM.GraphModel, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(edge, model::EasyABM.GraphModel, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.propnames","page":"API","title":"EasyABM.propnames","text":"propnames(obj::Union{EasyABM.AbstractAgent2D, EasyABM.AbstractAgent3D}) -> Vector{Symbol}\n\n\n\n\n\n\npropnames(obj::EasyABM.GraphAgent) -> Vector{Symbol}\n\n\n\n\n\n\npropnames(obj::EasyABM.AbstractPropDict) -> Vector{Symbol}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nums_agents","page":"API","title":"EasyABM.get_nums_agents","text":"get_nums_agents(model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, Mortal}, EasyABM.AbstractSpaceModel{Mortal}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_nums_agents(model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, Static}, EasyABM.AbstractSpaceModel{Static}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nums_patches","page":"API","title":"EasyABM.get_nums_patches","text":"get_nums_patches(model::EasyABM.AbstractSpaceModel, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nums_nodes","page":"API","title":"EasyABM.get_nums_nodes","text":"get_nums_nodes(model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_nums_nodes(model::Union{EasyABM.GraphModel{Static, Mortal}, EasyABM.GraphModel{Static, Static}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nums_edges","page":"API","title":"EasyABM.get_nums_edges","text":"get_nums_edges(model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_nums_edges(model::Union{EasyABM.GraphModel{Static, Mortal}, EasyABM.GraphModel{Static, Static}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_agents_avg_props","page":"API","title":"EasyABM.get_agents_avg_props","text":"\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_patches_avg_props","page":"API","title":"EasyABM.get_patches_avg_props","text":"get_patches_avg_props(model::EasyABM.AbstractSpaceModel, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nodes_avg_props","page":"API","title":"EasyABM.get_nodes_avg_props","text":"get_nodes_avg_props(model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_nodes_avg_props(model::Union{EasyABM.GraphModel{Static, Mortal}, EasyABM.GraphModel{Static, Static}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_edges_avg_props","page":"API","title":"EasyABM.get_edges_avg_props","text":"get_edges_avg_props(model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_edges_avg_props(model::Union{EasyABM.GraphModel{Static, Mortal}, EasyABM.GraphModel{Static, Static}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.save_model","page":"API","title":"EasyABM.save_model","text":"save_model(model; model_name, save_as, folder) -> Union{Nothing, Int64}\n\n\nSaves the model on disk as jld2 file. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.open_saved_model","page":"API","title":"EasyABM.open_saved_model","text":"open_saved_model(; model_name, path) -> Any\n\n\nGets the model that was saved before as jld2. \n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-creating-and-modifying-a-graph","page":"API","title":"Functions for creating and modifying a graph","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"static_simple_graph\nstatic_dir_graph\ndynamic_simple_graph\ndynamic_dir_graph\nhex_grid_graph\nsquare_grid_graph\ntriangular_grid_graph\ndouble_triangular_grid_graph\ndraw_graph\nadd_node!\nadd_nodes!\nkill_node!\ncreate_edge! \nkill_edge!\nkill_all_edges!\nflush_graph!\nis_digraph\nis_static","category":"page"},{"location":"api/#EasyABM.static_simple_graph","page":"API","title":"EasyABM.static_simple_graph","text":"static_simple_graph(n::Int64) -> EasyABM.SimplePropGraph{Static, EasyABM.SimG}\n\n\nCreates a simple prop graph with n vertices. \n\n\n\n\n\nstatic_simple_graph(structure::Dict{Int64, Vector{Int64}}) -> Union{Nothing, EasyABM.SimplePropGraph{Static, EasyABM.SimG}}\n\n\nCreates a simple prop graph with given structure. \n\n\n\n\n\nstatic_simple_graph(A::Matrix{Int64}) -> Union{Nothing, EasyABM.SimplePropGraph{Static, EasyABM.SimG}}\n\n\nCreates a simple prop graph for given Adjacency matrix. \n\n\n\n\n\nstatic_simple_graph(A::SparseArrays.SparseMatrixCSC{Int64, Int64}) -> Union{Nothing, EasyABM.SimplePropGraph{Static, EasyABM.SimG}}\n\n\nCreates a simple prop graph for adjacency_matrix given as a Sparse Matrix. \n\n\n\n\n\nstatic_simple_graph(g::Graphs.SimpleGraphs.SimpleGraph{Int64}) -> Union{Nothing, EasyABM.SimplePropGraph{Static, EasyABM.SimG}}\n\n\nCreates a simple prop graph from a given simple graph created with Graphs.jl. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.static_dir_graph","page":"API","title":"EasyABM.static_dir_graph","text":"static_dir_graph(n::Int64) -> EasyABM.DirPropGraph{Static, EasyABM.DirG}\n\n\nCreates a directed prop graph with n vertices. \n\n\n\n\n\nstatic_dir_graph(in_structure::Dict{Int64, Vector{Int64}}) -> Union{Nothing, EasyABM.DirPropGraph{Static, EasyABM.DirG}}\n\n\nCreates a directed prop graph with given structure. \n\n\n\n\n\nstatic_dir_graph(A::Matrix{Int64}) -> Union{Nothing, EasyABM.DirPropGraph{Static, EasyABM.DirG}}\n\n\nCreates a directed prop graph for given Adjacency matrix. \n\n\n\n\n\nstatic_dir_graph(A::SparseArrays.SparseMatrixCSC{Int64, Int64}) -> Union{Nothing, EasyABM.DirPropGraph{Static, EasyABM.DirG}}\n\n\nCreates a directed prop graph for adjacency matrix given as a Sparse Matrix. \n\n\n\n\n\nstatic_dir_graph(g::Graphs.SimpleGraphs.SimpleDiGraph{Int64}) -> Union{Nothing, EasyABM.DirPropGraph{Static, EasyABM.DirG}}\n\n\nCreates a directed prop graph for a given directed graph created with Graphs.jl. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.dynamic_simple_graph","page":"API","title":"EasyABM.dynamic_simple_graph","text":"dynamic_simple_graph(n::Int64) -> EasyABM.SimplePropGraph{Mortal, EasyABM.SimG}\n\n\nCreates a simple prop graph with n vertices. \n\n\n\n\n\ndynamic_simple_graph(structure::Dict{Int64, Vector{Int64}}) -> Union{Nothing, EasyABM.SimplePropGraph{Mortal, EasyABM.SimG}}\n\n\nCreates a simple prop graph with given structure. \n\n\n\n\n\ndynamic_simple_graph(A::Matrix{Int64}) -> Union{Nothing, EasyABM.SimplePropGraph{Mortal, EasyABM.SimG}}\n\n\nCreates a simple prop graph for given Adjacency matrix. \n\n\n\n\n\ndynamic_simple_graph(A::SparseArrays.SparseMatrixCSC{Int64, Int64}) -> Union{Nothing, EasyABM.SimplePropGraph{Mortal, EasyABM.SimG}}\n\n\nCreates a simple prop graph for adjacency_matrix given as a Sparse Matrix. \n\n\n\n\n\ndynamic_simple_graph(g::Graphs.SimpleGraphs.SimpleGraph{Int64}) -> Union{Nothing, EasyABM.SimplePropGraph{Mortal, EasyABM.SimG}}\n\n\nCreates a simple prop graph from a given simple graph created with Graphs.jl. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.dynamic_dir_graph","page":"API","title":"EasyABM.dynamic_dir_graph","text":"dynamic_dir_graph(n::Int64) -> EasyABM.DirPropGraph{Mortal, EasyABM.DirG}\n\n\nCreates a directed prop graph with n vertices. \n\n\n\n\n\ndynamic_dir_graph(in_structure::Dict{Int64, Vector{Int64}}) -> Union{Nothing, EasyABM.DirPropGraph{Mortal, EasyABM.DirG}}\n\n\nCreates a directed prop graph with given structure. \n\n\n\n\n\ndynamic_dir_graph(A::Matrix{Int64}) -> Union{Nothing, EasyABM.DirPropGraph{Mortal, EasyABM.DirG}}\n\n\nCreates a directed prop graph for given Adjacency matrix. \n\n\n\n\n\ndynamic_dir_graph(A::SparseArrays.SparseMatrixCSC{Int64, Int64}) -> Union{Nothing, EasyABM.DirPropGraph{Mortal, EasyABM.DirG}}\n\n\nCreates a directed prop graph for adjacency matrix given as a Sparse Matrix. \n\n\n\n\n\ndynamic_dir_graph(g::Graphs.SimpleGraphs.SimpleDiGraph{Int64}) -> Union{Nothing, EasyABM.DirPropGraph{Mortal, EasyABM.DirG}}\n\n\nCreates a directed prop graph for a given directed graph created with Graphs.jl. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.hex_grid_graph","page":"API","title":"EasyABM.hex_grid_graph","text":"hex_grid_graph(n, k) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.square_grid_graph","page":"API","title":"EasyABM.square_grid_graph","text":"square_grid_graph(n, k; periodic) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.triangular_grid_graph","page":"API","title":"EasyABM.triangular_grid_graph","text":"triangular_grid_graph(n, k) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.double_triangular_grid_graph","page":"API","title":"EasyABM.double_triangular_grid_graph","text":"double_triangular_grid_graph(n, k) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.draw_graph","page":"API","title":"EasyABM.draw_graph","text":"draw_graph(graph) -> Union{Nothing, Luxor.Drawing}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.add_node!","page":"API","title":"EasyABM.add_node!","text":"add_node!(model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}; kwargs...) -> Int64\n\n\nAdds a node with properties specified in kwargs to the model's graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.add_nodes!","page":"API","title":"EasyABM.add_nodes!","text":"add_nodes!(n, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}; kwargs...)\n\n\nAdds n nodes with properties specified in kwargs to the model's graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.kill_node!","page":"API","title":"EasyABM.kill_node!","text":"kill_node!(node, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}) -> Union{Nothing, Int64}\n\n\nRemoves a node from model graph. For performance reasons the function does not check if the node contains the node so it will throw an error if the user tries to delete a node which is not there. Also the node will not be deleted if the agents in the model can not be killed and the number of agents at the given node is nonzero.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_edge!","page":"API","title":"EasyABM.create_edge!","text":"create_edge!(i, j, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}; kwargs...)\n\n\nAdds an edge with properties kwargs to model graph. \n\n\n\n\n\ncreate_edge!(edge, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}; kwargs...)\n\n\nAdds an edge with properties kwargs to model graph. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.kill_edge!","page":"API","title":"EasyABM.kill_edge!","text":"kill_edge!(i, j, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}) -> Union{Nothing, EasyABM.PropDataDict{Symbol, Any}}\n\n\nRemoves edge from the model graph. \n\n\n\n\n\nkill_edge!(edge, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}) -> Union{Nothing, EasyABM.PropDataDict{Symbol, Any}}\n\n\nRemoves edge from the model graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.kill_all_edges!","page":"API","title":"EasyABM.kill_all_edges!","text":"kill_all_edges!(model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}})\n\n\nRemoves all edges from the model graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.flush_graph!","page":"API","title":"EasyABM.flush_graph!","text":"flush_graph!(model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Mortal, Static}}) -> Int64\n\n\nRemoves the graph and all of related data completely. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.is_digraph","page":"API","title":"EasyABM.is_digraph","text":"is_digraph(g::EasyABM.SimplePropGraph) -> Bool\n\n\n\n\n\n\nis_digraph(g::EasyABM.DirPropGraph) -> Bool\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.is_static","page":"API","title":"EasyABM.is_static","text":"is_static(g::EasyABM.SimplePropGraph{T<:EasyABM.MType}) -> Bool\n\n\n\n\n\n\nis_static(g::EasyABM.DirPropGraph{T<:EasyABM.MType}) -> Bool\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Helper-functions-for-agents","page":"API","title":"Helper functions for agents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_grid_loc\nget_node_loc\nget_id\nagents_at\nnum_agents_at\nagent_with_id\nis_alive\nget_agents \nnum_agents \nkill_agent!\nadd_agent!","category":"page"},{"location":"api/#EasyABM.get_grid_loc","page":"API","title":"EasyABM.get_grid_loc","text":"get_grid_loc(agent::EasyABM.Agent2D{Symbol, Any, <:AbstractFloat}) -> Tuple{Int64, Int64}\n\n\nReturns grid location of the agent.\n\n\n\n\n\nget_grid_loc(agent::EasyABM.Agent2D{Symbol, Any, Int64}) -> Vect{2, <:Int64}\n\n\nReturns grid location of the agent.\n\n\n\n\n\nget_grid_loc(agent::EasyABM.Agent3D{Symbol, Any, <:AbstractFloat}) -> Tuple{Int64, Int64, Int64}\n\n\nReturns grid location of the agent.\n\n\n\n\n\nget_grid_loc(agent::EasyABM.Agent3D{Symbol, Any, Int64}) -> Vect{3, <:Int64}\n\n\nReturns grid location of the agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_node_loc","page":"API","title":"EasyABM.get_node_loc","text":"get_node_loc(agent::EasyABM.GraphAgent) -> Int64\n\n\nReturns node location of the agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_id","page":"API","title":"EasyABM.get_id","text":"get_id(agent::EasyABM.AbstractAgent) -> Any\n\n\nReturns agents id.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.agents_at","page":"API","title":"EasyABM.agents_at","text":"agents_at(patch, model::EasyABM.SpaceModel2D) -> Base.Generator\n\n\nReturns list of agents at a given patch.\n\n\n\n\n\nagents_at(patch, model::EasyABM.SpaceModel3D) -> Base.Generator\n\n\nReturns list of agents at a given patch.\n\n\n\n\n\nagents_at(node, model::EasyABM.GraphModel{Mortal, T<:EasyABM.MType}) -> Base.Generator\n\n\nReturns list of agents at a given node. \n\n\n\n\n\nagents_at(node, model::EasyABM.GraphModel{Static, T<:EasyABM.MType}) -> Base.Generator\n\n\nReturns list of agents at a given node. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_agents_at","page":"API","title":"EasyABM.num_agents_at","text":"num_agents_at(patch, model::EasyABM.AbstractSpaceModel) -> Int64\n\n\nReturns number of agents at a given patch.\n\n\n\n\n\nnum_agents_at(node, model::EasyABM.AbstractGraphModel) -> Int64\n\n\nReturns number of agents at a given node. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.agent_with_id","page":"API","title":"EasyABM.agent_with_id","text":"agent_with_id(i::Int64, model::EasyABM.SpaceModel2D{Mortal, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}) -> Union{Nothing, EasyABM.Agent2D{Symbol, Any}}\n\n\nReturns agent having given id.\n\n\n\n\n\nagent_with_id(i::Int64, model::EasyABM.SpaceModel2D{Static}) -> Union{Nothing, EasyABM.Agent2D{Symbol, Any}}\n\n\nReturns agent having given id.\n\n\n\n\n\nagent_with_id(i::Int64, model::EasyABM.SpaceModel3D{Mortal, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}) -> Union{Nothing, EasyABM.Agent3D{Symbol, Any}}\n\n\nReturns agent having given id.\n\n\n\n\n\nagent_with_id(i::Int64, model::EasyABM.SpaceModel3D{Static}) -> Union{Nothing, EasyABM.Agent3D{Symbol, Any}}\n\n\nReturns agent having given id.\n\n\n\n\n\nagent_with_id(i::Int64, model::EasyABM.GraphModel{T<:EasyABM.MType, Mortal}) -> Union{Nothing, EasyABM.GraphAgent{Symbol, Any}}\n\n\nReturns agent having given id.\n\n\n\n\n\nagent_with_id(i::Int64, model::EasyABM.GraphModel{T<:EasyABM.MType, Static}) -> Union{Nothing, EasyABM.GraphAgent{Symbol, Any}}\n\n\nReturns agent having given id.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.is_alive","page":"API","title":"EasyABM.is_alive","text":"is_alive(agent::EasyABM.AbstractPropDict) -> Bool\n\n\nReturns true if agent is alive else returns false.\n\n\n\n\n\nis_alive(node, model::EasyABM.AbstractGraphModel) -> Bool\n\n\nReturns true if a node is alive else returns false.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_agents","page":"API","title":"EasyABM.get_agents","text":"get_agents(model::EasyABM.SpaceModel2D{Mortal, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel2D{Mortal, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}) -> Base.Iterators.Filter{EasyABM.var\"#176#178\"}\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel2D{Static}, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel2D{Static}) -> Base.Generator{_A, typeof(identity)} where _A\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel3D{Mortal, S<:(Union{Int64, var\"#s174\"} where var\"#s174\"<:AbstractFloat), P<:EasyABM.SType}, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel3D{Mortal, S<:(Union{Int64, var\"#s174\"} where var\"#s174\"<:AbstractFloat), P<:EasyABM.SType}) -> Base.Iterators.Filter{EasyABM.var\"#327#329\"}\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel3D{Static}, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel3D{Static}) -> Base.Generator{_A, typeof(identity)} where _A\n\n\n\n\n\n\nget_agents(model::EasyABM.GraphModel{T<:EasyABM.MType, Mortal}, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_agents(model::EasyABM.GraphModel{T<:EasyABM.MType, Mortal}) -> Base.Iterators.Filter{EasyABM.var\"#483#485\"}\n\n\n\n\n\n\nget_agents(model::EasyABM.GraphModel{T<:EasyABM.MType, Static}, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_agents(model::EasyABM.GraphModel{T<:EasyABM.MType, Static}) -> Base.Generator{_A, typeof(identity)} where _A\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_agents","page":"API","title":"EasyABM.num_agents","text":"num_agents(model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractSpaceModel}, condition::Function) -> Any\n\n\n\n\n\n\nnum_agents(model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractSpaceModel}) -> Int64\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.kill_agent!","page":"API","title":"EasyABM.kill_agent!","text":"kill_agent!(agent::EasyABM.AbstractAgent, model::EasyABM.AbstractSpaceModel{Mortal}) -> Union{Nothing, Int64}\n\n\nSets the agent as inactive thus effectively removing from the model. However, the removed agents  are permanently removed from the list model.agents only twice in one step i) After the agent_step_function  has run for all agents and ii) After the step_rule.\n\n\n\n\n\nkill_agent!(agent::EasyABM.AbstractAgent, model::EasyABM.AbstractGraphModel{T<:EasyABM.MType, Mortal}) -> Union{Nothing, Int64}\n\n\nSets the agent as inactive thus effectively removing from the model. However, the removed agents  are permanently removed from the list model.agents only after each step.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.add_agent!","page":"API","title":"EasyABM.add_agent!","text":"add_agent!(agent, model::EasyABM.SpaceModel2D{Mortal}) -> Union{Nothing, Int64}\n\n\nAdds the agent to the model.\n\n\n\n\n\nadd_agent!(agent, model::EasyABM.SpaceModel3D{Mortal}) -> Union{Nothing, Int64}\n\n\nAdds the agent to the model.\n\n\n\n\n\nadd_agent!(agent, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Static, Mortal}}) -> Union{Nothing, Int64}\n\n\nAdds the agent to the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-getting-neighbor-agents.","page":"API","title":"Functions for getting neighbor agents.","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"neighbors\nin_neighbors\nout_neighbors\ngrid_neighbors\neuclidean_neighbors","category":"page"},{"location":"api/#EasyABM.neighbors","page":"API","title":"EasyABM.neighbors","text":"Returns active neighboring agents to given agent. If the metric is :grid, then with dist =0 only agents present in the current  block of the given agent are returned; with dist=1, agents in the current block of the given agent along with agents in the neighbouring  8 blocks are returned; with dist=2 agents in the current block of given agent, along with agents in 24 nearest blocks are returned, and  so on. With metric = :euclidean the agents within Euclidean distance dist are returned.\n\n\n\n\n\nneighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{Static}) -> Any\nneighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{Static}, dist::Number; metric) -> Any\n\n\nReturns active neighboring agents to given agent. If the metric is :grid, then with dist =0 only agents present in the current  block of the given agent are returned; with dist=1, agents in the current block of the given agent along with agents in the neighbouring  8 blocks are returned; with dist=2 agents in the current block of given agent, along with agents in 24 nearest blocks are returned, and  so on. With metric = :euclidean the agents within Euclidean distance dist are returned.\n\n\n\n\n\nReturns active neighboring agents to given agent. If the metric is :grid, then with dist =0 only agents present in the current  block of the given agent are returned; with dist=1, agents in the current block of the given agent along with agents in the neighbouring  8 blocks are returned; with dist=2 agents in the current block of given agent, along with agents in 24 nearest blocks are returned, and  so on. With metric = :euclidean the agents within Euclidean distance dist are returned.\n\n\n\n\n\nneighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{Static}) -> Any\nneighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{Static}, dist::Number; metric) -> Any\n\n\nReturns active neighboring agents to given agent. If the metric is :grid, then with dist =0 only agents present in the current  block of the given agent are returned; with dist=1, agents in the current block of the given agent along with agents in the neighbouring  8 blocks are returned; with dist=2 agents in the current block of given agent, along with agents in 24 nearest blocks are returned, and  so on. With metric = :euclidean the agents within Euclidean distance dist are returned.\n\n\n\n\n\nneighbors(agent::EasyABM.GraphAgent, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Static, Mortal}}) -> Union{Base.Generator{UnitRange{Int64}, typeof(identity)}, Base.Iterators.Flatten}\n\n\nReturns agents on neighboring nodes of given agent.\n\n\n\n\n\nneighbors(agent::EasyABM.GraphAgent, model::Union{EasyABM.GraphModel{Mortal, Static}, EasyABM.GraphModel{Static, Static}}) -> Base.Iterators.Flatten\n\n\nReturns agents on neighboring nodes of given agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.in_neighbors","page":"API","title":"EasyABM.in_neighbors","text":"in_neighbors(agent::EasyABM.GraphAgent, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Static, Mortal}}) -> Union{Base.Generator{UnitRange{Int64}, typeof(identity)}, Base.Iterators.Flatten}\n\n\nReturns agents on neighboring incoming nodes of given agent.\n\n\n\n\n\nin_neighbors(agent::EasyABM.GraphAgent, model::Union{EasyABM.GraphModel{Mortal, Static}, EasyABM.GraphModel{Static, Static}}) -> Base.Iterators.Flatten\n\n\nReturns agents on neighboring incoming nodes of given agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.out_neighbors","page":"API","title":"EasyABM.out_neighbors","text":"out_neighbors(agent::EasyABM.GraphAgent, model::Union{EasyABM.GraphModel{Mortal, Mortal}, EasyABM.GraphModel{Static, Mortal}}) -> Union{Base.Generator{UnitRange{Int64}, typeof(identity)}, Base.Iterators.Flatten}\n\n\nReturns agents on neighboring outgoing nodes of given agent.\n\n\n\n\n\nout_neighbors(agent::EasyABM.GraphAgent, model::Union{EasyABM.GraphModel{Mortal, Static}, EasyABM.GraphModel{Static, Static}}) -> Base.Iterators.Flatten\n\n\nReturns agents on neighboring outgoing nodes of given agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.grid_neighbors","page":"API","title":"EasyABM.grid_neighbors","text":"grid_neighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{Mortal, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}) -> Any\ngrid_neighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{Mortal, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}, dist::Int64) -> Any\n\n\n\n\n\n\ngrid_neighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{Static}) -> Any\ngrid_neighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{Static}, dist::Int64) -> Any\n\n\n\n\n\n\ngrid_neighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{Mortal, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}) -> Any\ngrid_neighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{Mortal, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}, dist::Int64) -> Any\n\n\n\n\n\n\ngrid_neighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{Static}) -> Any\ngrid_neighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{Static}, dist::Int64) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.euclidean_neighbors","page":"API","title":"EasyABM.euclidean_neighbors","text":"euclidean_neighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{Mortal, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}) -> Any\neuclidean_neighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{Mortal, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}, dist::Number) -> Any\n\n\n\n\n\n\neuclidean_neighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{Static}) -> Base.Iterators.Filter\neuclidean_neighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{Static}, dist::Number) -> Base.Iterators.Filter\n\n\n\n\n\n\neuclidean_neighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{Mortal, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}) -> Any\neuclidean_neighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{Mortal, S<:Union{Int64, AbstractFloat}, P<:EasyABM.SType}, dist::Number) -> Any\n\n\n\n\n\n\neuclidean_neighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{Static}) -> Base.Iterators.Filter\neuclidean_neighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{Static}, dist::Number) -> Base.Iterators.Filter\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Helper-functions-for-patches,-nodes,-edges","page":"API","title":"Helper functions for patches, nodes, edges","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"is_occupied\nget_nodeprop\nget_edgeprop\nset_nodeprops!\nset_edgeprops!\nget_patchprop\nset_patchprops!\nneighbor_nodes\nneighbor_patches\nin_neighbor_nodes\nout_neighbor_nodes\nget_nodes\nnum_nodes\nget_edges\nnum_edges\nget_patches\nnum_patches\nrandom_empty_node\nrandom_empty_patch","category":"page"},{"location":"api/#EasyABM.is_occupied","page":"API","title":"EasyABM.is_occupied","text":"is_occupied(patch, model::EasyABM.AbstractSpaceModel) -> Any\n\n\nReturns true if a patch is occupied.\n\n\n\n\n\nis_occupied(node, model::EasyABM.AbstractGraphModel) -> Any\n\n\nReturns true if a node is occupied. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nodeprop","page":"API","title":"EasyABM.get_nodeprop","text":"get_nodeprop(key::Symbol, node::Int64, model::EasyABM.GraphModel) -> Any\n\n\nReturns the value for given property name for a node.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_edgeprop","page":"API","title":"EasyABM.get_edgeprop","text":"get_edgeprop(key::Symbol, i::Int64, j::Int64, model::EasyABM.GraphModel) -> Any\n\n\nReturns the value for given property name for an edge.\n\n\n\n\n\nget_edgeprop(key::Symbol, edge, model::EasyABM.GraphModel) -> Any\n\n\nReturns the value for given property name for an edge.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.set_nodeprops!","page":"API","title":"EasyABM.set_nodeprops!","text":"set_nodeprops!(node::Int64, model::EasyABM.GraphModel; kwargs...)\n\n\nSets properties of given node.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.set_edgeprops!","page":"API","title":"EasyABM.set_edgeprops!","text":"set_edgeprops!(i::Int64, j::Int64, model::EasyABM.GraphModel; kwargs...)\n\n\nSets properties of given edge.\n\n\n\n\n\nset_edgeprops!(edge, model::EasyABM.GraphModel; kwargs...)\n\n\nSets properties of given edge.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_patchprop","page":"API","title":"EasyABM.get_patchprop","text":"get_patchprop(key, patch, model::EasyABM.AbstractSpaceModel) -> Any\n\n\nReturns value of given property of a patch. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.set_patchprops!","page":"API","title":"EasyABM.set_patchprops!","text":"set_patchprops!(patch, model::EasyABM.AbstractSpaceModel; kwargs...)\n\n\nSets properties of the patch given as keyword arguments. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.neighbor_nodes","page":"API","title":"EasyABM.neighbor_nodes","text":"neighbor_nodes(node::Int64, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes neighboring given node.\n\n\n\n\n\nneighbor_nodes(agent::EasyABM.GraphAgent, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes neighboring node of the given agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.neighbor_patches","page":"API","title":"EasyABM.neighbor_patches","text":"neighbor_patches(patch::Tuple{Int64, Int64}, model::EasyABM.SpaceModel2D{T, S, P<:Periodic}, dist::Int64) -> Vector{Tuple{Int64, Int64}}\n\n\nReturns patches neighboring the given agent's patch.\n\n\n\n\n\nneighbor_patches(patch::Tuple{Int64, Int64}, model::EasyABM.SpaceModel2D{T, S, P<:NPeriodic}, dist::Int64) -> Vector{Tuple{Int64, Int64}}\n\n\nReturns patches neighboring the given agent's patch.\n\n\n\n\n\nneighbor_patches(agent::EasyABM.Agent2D{Symbol, Any, <:AbstractFloat}, model::EasyABM.SpaceModel2D, dist::Int64) -> Vector{Tuple{Int64, Int64}}\n\n\nReturns patches neighboring the given patch.\n\n\n\n\n\nneighbor_patches(agent::EasyABM.Agent2D{Symbol, Any, Int64}, model::EasyABM.SpaceModel2D, dist::Int64)\n\n\nReturns patches neighboring the given patch.\n\n\n\n\n\nneighbor_patches(patch::Tuple{Int64, Int64, Int64}, model::EasyABM.SpaceModel3D{T, S, P<:Periodic}, dist::Int64) -> Vector{Tuple{Int64, Int64, Int64}}\n\n\nReturns patches neighboring given agent's patch.\n\n\n\n\n\nneighbor_patches(patch::Tuple{Int64, Int64, Int64}, model::EasyABM.SpaceModel3D{T, S, P<:NPeriodic}, dist::Int64) -> Vector{Tuple{Int64, Int64, Int64}}\n\n\nReturns patches neighboring given agent's patch.\n\n\n\n\n\nneighbor_patches(agent::EasyABM.Agent3D{Symbol, Any, <:AbstractFloat}, model::EasyABM.SpaceModel3D, dist::Int64) -> Vector{Tuple{Int64, Int64, Int64}}\n\n\nReturns patches neighboring the given patch.\n\n\n\n\n\nneighbor_patches(agent::EasyABM.Agent3D{Symbol, Any, Int64}, model::EasyABM.SpaceModel3D, dist::Int64)\n\n\nReturns patches neighboring the given patch.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.in_neighbor_nodes","page":"API","title":"EasyABM.in_neighbor_nodes","text":"in_neighbor_nodes(node::Int64, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes of incoming edges at given node. \n\n\n\n\n\nin_neighbor_nodes(agent::EasyABM.GraphAgent, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes of incoming edges at given agent's node.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.out_neighbor_nodes","page":"API","title":"EasyABM.out_neighbor_nodes","text":"out_neighbor_nodes(node::Int64, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes of outgoing edges at given node.\n\n\n\n\n\nout_neighbor_nodes(agent::EasyABM.GraphAgent, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes of outgoing edges at given agent's node.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nodes","page":"API","title":"EasyABM.get_nodes","text":"get_nodes(model::EasyABM.GraphModel, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_nodes(model::EasyABM.GraphModel) -> Base.Generator{_A, typeof(identity)} where _A\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_nodes","page":"API","title":"EasyABM.num_nodes","text":"num_nodes(model::EasyABM.GraphModel, condition::Function) -> Int64\n\n\n\n\n\n\nnum_nodes(model::EasyABM.GraphModel) -> Int64\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_edges","page":"API","title":"EasyABM.get_edges","text":"get_edges(model::EasyABM.GraphModel, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_edges(model::EasyABM.GraphModel) -> Base.Iterators.Flatten\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_edges","page":"API","title":"EasyABM.num_edges","text":"num_edges(model::EasyABM.GraphModel, condition::Function) -> Int64\n\n\n\n\n\n\nnum_edges(model::EasyABM.GraphModel) -> Int64\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_patches","page":"API","title":"EasyABM.get_patches","text":"get_patches(model::EasyABM.SpaceModel2D, condition::Function) -> Base.Iterators.Filter\n\n\nReturns patches satisfying the given condition.\n\n\n\n\n\nget_patches(model::EasyABM.SpaceModel2D) -> Base.Iterators.Flatten\n\n\nReturns patches satisfying the given condition.\n\n\n\n\n\nget_patches(model::EasyABM.SpaceModel3D, condition::Function) -> Base.Iterators.Filter\n\n\nReturns patches satisfying given condition.\n\n\n\n\n\nget_patches(model::EasyABM.SpaceModel3D) -> Base.Iterators.Flatten\n\n\nReturns patches satisfying given condition.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_patches","page":"API","title":"EasyABM.num_patches","text":"num_patches(model::EasyABM.SpaceModel2D, condition::Function) -> Int64\n\n\nReturns number of patches satisfying the given condition.\n\n\n\n\n\nnum_patches(model::EasyABM.SpaceModel2D) -> Int64\n\n\nReturns number of patches satisfying the given condition.\n\n\n\n\n\nnum_patches(model::EasyABM.SpaceModel3D, condition::Function) -> Int64\n\n\nReturns number of patches satisfying given condition.\n\n\n\n\n\nnum_patches(model::EasyABM.SpaceModel3D) -> Int64\n\n\nReturns number of patches satisfying given condition.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.random_empty_node","page":"API","title":"EasyABM.random_empty_node","text":"random_empty_node(model::EasyABM.AbstractGraphModel) -> Any\n\n\nReturns an empty node chosen at random. Returns nothing if there is no empty node. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.random_empty_patch","page":"API","title":"EasyABM.random_empty_patch","text":"random_empty_patch(model::EasyABM.SpaceModel2D; search_method, attempts) -> Union{Nothing, Tuple{Int64, Int64}}\n\n\nReturns a random patch where no agents are present. Rerurns nothing if there is no such patch.\n\n\n\n\n\nrandom_empty_patch(model::EasyABM.SpaceModel3D; search_method, attempts) -> Union{Nothing, Tuple{Int64, Int64, Int64}}\n\n\nReturns a random patch where no agents are present. Returns nothing if there is no such patch.\n\n\n\n\n\n","category":"function"},{"location":"api/#Misc.-utility-functions","page":"API","title":"Misc. utility functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"dotprod\nveclength\ndistance\ncalculate_direction","category":"page"},{"location":"api/#EasyABM.dotprod","page":"API","title":"EasyABM.dotprod","text":"dotprod(a::Vect{N}, b::Vect{N}) -> Any\n\n\n\n\n\n\ndotprod(a::Tuple{Vararg{var\"#s21\", N}} where var\"#s21\"<:Union{AbstractFloat, Integer}, b::Tuple{Vararg{var\"#s20\", N}} where var\"#s20\"<:Union{AbstractFloat, Integer}) -> Any\n\n\n\n\n\n\ndotprod(a::Union{EasyABM.AbstractAgent2D, EasyABM.AbstractAgent3D}, b::Union{EasyABM.AbstractAgent2D, EasyABM.AbstractAgent3D}) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.veclength","page":"API","title":"EasyABM.veclength","text":"veclength(a::GeometryBasics.Vec)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.distance","page":"API","title":"EasyABM.distance","text":"distance(a::GeometryBasics.Vec, b::GeometryBasics.Vec) -> Any\n\n\n\n\n\n\ndistance(a::Tuple{Vararg{Union{AbstractFloat, Integer}, N}}, b::Tuple{Vararg{Union{AbstractFloat, Integer}, N}}) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.calculate_direction","page":"API","title":"EasyABM.calculate_direction","text":"calculate_direction(vel::Union{Tuple{T<:Real, T<:Real}, Vect{2, T<:Real}}) -> Any\n\n\n\n\n\n\ncalculate_direction(vel::Union{Tuple{T<:Real, T<:Real, T<:Real}, Vect{3, T<:Real}}) -> Union{Float64, Vect}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"boids/#Flocking","page":"Flocking","title":"Flocking","text":"","category":"section"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"using EasyABM","category":"page"},{"location":"boids/#Step-1:-Create-Agents-and-Model","page":"Flocking","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"Lets create 200 agents with properties shape, pos, vel and orientation (The orientation property is used internally by EasyABM to draw the direction agent is facing). The position pos is only accepted as a Vect which is an inbuilt vector type in EasyABM. It is also recommended for both convenience as well as performance to use Vect type for any vectorial properties in the model such as velocity and forces. The keeps_record_of argument is list of properties that the agent will record during time evolution. The model is defined with parameters:","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"min_dis : The distance between boids below which they start repelling each other.\ncoh_fac : The proportionality constant for the cohere force. \nsep_fac : The proportionality constant for the separation force.\naln_fac : The proportionality constant for the alignment force.\nvis_range : The visual range of boids.\ndt : The proportionality constant between change in position and velocity.","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"The argument agents_type is set to Static which means that the boids number will remain fixed during simulation. ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"boids = con_2d_agents(200, shape = :arrow, pos = Vect(0.0,0.0), \n    vel=Vect(0.0,0.0), orientation = 0.0, keeps_record_of = [:pos, :vel, :orientation])\nmodel = create_2d_model(boids,\n    agents_type=Static, space_type = Periodic, \n    min_dis = 0.3, coh_fac = 0.05, \n    sep_fac = 0.5, dt= 0.1, vis_range = 2.0, aln_fac = 0.35)","category":"page"},{"location":"boids/#Step-2:-Initialise-the-model","page":"Flocking","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"In this step we set the positions, velocities and orientations of boids and initialise the model.","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"function initialiser!(model)\n    xdim, ydim = model.size\n    for boid in model.agents\n        boid.pos = Vect(rand()*xdim, rand()*ydim)\n        boid.orientation = rand()*2*3.14\n        boid.vel = Vect(-sin(boid.orientation), cos(boid.orientation))\n    end\nend\n\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"boids/#Step-3:-Run-the-model","page":"Flocking","title":"Step 3: Run the model","text":"","category":"section"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"In this step we implement the step logic of the flocking model in the step_rule! function and run the model for 500 steps. ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"\nconst ep = 0.00001\n\nfunction step_rule!(model)\n    dt = model.parameters.dt\n    for boid in model.agents\n        nbrs = euclidean_neighbors(boid, model, model.parameters.vis_range)\n        coh_force = Vect(0.0,0.0) # For a Vect all coordinates must be of same type\n        sep_force = Vect(0.0,0.0) \n        aln_force = Vect(0.0,0.0)\n        num = 0\n        for nbr in nbrs\n            num+=1\n            vec = nbr.pos - boid.pos\n            coh_force += vec\n            if veclength(vec)< model.parameters.min_dis\n                sep_force -= vec\n            end\n            aln_force += nbr.vel\n        end\n        aln_force = num>0 ? (aln_force / num - boid.vel) * model.parameters.aln_fac : aln_force\n        num = max(1, num)\n        coh_force *= (model.parameters.coh_fac / num)\n        sep_force *=  model.parameters.sep_fac\n        boid.vel  += (coh_force + sep_force) + aln_force\n        boid.vel  /= (veclength(boid.vel)+ep)\n        boid.orientation = calculate_direction(boid.vel)\n        boid.pos += boid.vel*dt\n    end\nend\n\nrun_model!(model, steps=500, step_rule = step_rule!)","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"animate_sim(model)","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"(Image: png)","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[(:min_dis, :s, 0.01:0.1:1.0),\n        (:coh_fac, :s, 0.01:0.01:1.0),\n        (:sep_fac, :s, 0.01:0.01:1.0),\n        (:aln_fac, :s, 0.01:0.01:1.0),\n        (:vis_range, :s, 0.5:0.5:4.0)], frames=400) ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"(Image: png)","category":"page"},{"location":"boids/#Step-4:-Fetch-Data","page":"Flocking","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"It is easy to fetch any data recorded during simulation. For example, the data of average velocity of agents at each time step can be obtained as - ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"df = get_agents_avg_props(model, agent -> agent.vel, labels = [\"average velocity\"])","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"boids/","page":"Flocking","title":"Flocking","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"stone_paper_scissor/#Stone-Paper-Scissor","page":"Rock-Paper-Scissor","title":"Stone Paper Scissor","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"using EasyABM","category":"page"},{"location":"stone_paper_scissor/#Step-1:-Create-Model","page":"Rock-Paper-Scissor","title":"Step 1: Create Model","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"In this model, we work with patches instead of agents. We set grid_size to (50,50), set space_type to Periodic and define an additional model parameter threshold whose value is set to 3. ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"model = create_2d_model(size = (50,50), space_type = Periodic, threshold = 3)","category":"page"},{"location":"stone_paper_scissor/#Step-2:-Initialise-the-model","page":"Rock-Paper-Scissor","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"In the second step we initialise the agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we randomly assign :red (for stone), :green (for paper) and :blue (for scissor) color to patches. Then we initialise the model using init_model! function, in which through the argument props_to_record, we tell EasyABM to record the :color property of patches during time evolution. Note that, in EasyABM animations are created with the recorded data, therefore if in the present model, the color of patches is not recorded there will be no animation to see. ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"function initialiser!(model)\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            num = rand()\n            if num<0.33\n                model.patches[i,j].color = :red # stone => red, paper => green, scissor => blue\n            elseif num>0.66\n                model.patches[i,j].color = :green\n            else\n                model.patches[i,j].color = :blue\n            end\n        end\n    end\nend\n\ninit_model!(model, initialiser = initialiser!, props_to_record = Dict(\"patches\" => [:color]))","category":"page"},{"location":"stone_paper_scissor/#Step-3:-Run-the-model","page":"Rock-Paper-Scissor","title":"Step 3: Run the model","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"In this step we define the step_rule! function and run the model for 400 steps. The rule of the game is very simple. The :red color of a patch will change to :green if number of neighboring patches with color :green exceeds the threshold( which we set to be 3 in the beginning). Similarly, if a :green patch finds larger than the threshold number of :blue patches in its neighborhood, it will change to :blue, and if a :blue patch finds larger than threshold number of :red patches in its neighborhood it will change to :red. Each step of the model consists of 500 Monte-Carlo steps in which a patch is selected at random and the above mentioned rule applied to it. ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"const who_wins_against = Dict(:red => :green, :green => :blue, :blue => :red)\n\nfunction step_rule!(model)\n    for _ in 1:500\n        i = rand(1:model.size[1])\n        j = rand(1:model.size[2])\n        nbr_patches = neighbor_patches((i,j), model, 1)\n        col = model.patches[i,j].color\n        winner_col = who_wins_against[col]\n        count = 0 \n        for patch in nbr_patches\n            if model.patches[patch...].color == winner_col\n                count+=1\n            end\n        end\n        if count > model.parameters.threshold\n            model.patches[i,j].color = winner_col\n        end\n    end\nend\n\nrun_model!(model, steps = 400, step_rule = step_rule!)","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"animate_sim(model, show_grid=true)","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"(Image: png)","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"create_interactive_app(model, initialiser= initialiser!,\n    props_to_record = Dict(\"patches\" => [:color]),\n    step_rule= step_rule!,\n    model_controls=[(:threshold, :s, 1:8)], \n    frames=400, show_grid=true) ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"(Image: png)","category":"page"},{"location":"stone_paper_scissor/#Step-4:-Fetch-Data","page":"Rock-Paper-Scissor","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"It is easy to fetch any recorded data after running the model. For example, the numbers of different colored patches at all timesteps can be got as follows","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"df = get_nums_patches(model, \n    patch-> patch.color ==:red, \n    patch-> patch.color ==:green, \n    patch-> patch.color ==:blue, labels=[\"stone\",\"paper\",\"scissor\"], plot_result=true)","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"(Image: png)","category":"page"},{"location":"boids3d/#Flocking","page":"Flocking","title":"Flocking","text":"","category":"section"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"using EasyABM","category":"page"},{"location":"boids3d/#Step-1:-Create-Agents-and-Model","page":"Flocking","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"Lets create 200 agents with properties shape, pos, vel and orientation (The orientation property is used internally by EasyABM to draw the direction agent is facing). The position pos is only accepted as a Vect which is an inbuilt vector type in EasyABM. It is also recommended for both convenience as well as performance to use Vect type for any vectorial properties in the model such as velocity and forces. The keeps_record_of argument is list of properties that the agent will record during time evolution. The model is defined with parameters:","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"min_dis : The distance between boids below which they start repelling each other.\ncoh_fac : The proportionality constant for the cohere force. \nsep_fac : The proportionality constant for the separation force.\naln_fac : The proportionality constant for the alignment force.\nvis_range : The visual range of boids.\ndt : The proportionality constant between change in position and velocity.","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"The argument agents_type is Static which means that the boids number will remain fixed during simulation. ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"boids = con_3d_agents(200, shape = :cone, pos = Vect(0.0,0.0,0.0), \n    vel=Vect(0.0,0.0,0.0), orientation = 0.0, keeps_record_of = [:pos, :orientation])\nmodel = create_3d_model(boids, agents_type=Static, \n    space_type = Periodic, min_dis = 0.3, coh_fac = 0.05, \n    sep_fac = 0.5, dt= 0.1, vis_range = 2.0, aln_fac = 0.35)","category":"page"},{"location":"boids3d/#Step-2:-Initialise-the-model","page":"Flocking","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"In this step we set the positions, velocities and orientations of boids and initialise the model.","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"function initialiser!(model)\n    xdim, ydim, zdim = model.size\n    for boid in model.agents\n        boid.pos = Vect(rand()*xdim, rand()*ydim, rand()*zdim)\n        boid.vel = Vect(1-2*rand(), 1-2*rand(), 1-2*rand())\n        boid.vel ./= veclength(boid.vel)\n        boid.orientation = boid.vel\n    end\nend\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"boids3d/#Step-3:-Run-the-model","page":"Flocking","title":"Step 3: Run the model","text":"","category":"section"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"In this step we implement the step logic of the flocking model in the step_rule! function and run the model for 500 steps. ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"\nconst ep = 0.00001 # to avoid division by zero\n\nfunction step_rule!(model)\n    dt = model.parameters.dt\n    for boid in model.agents\n        nbrs = euclidean_neighbors(boid, model, model.parameters.vis_range)\n        coh_force = Vect(0.0,0.0,0.0) \n        sep_force = Vect(0.0,0.0,0.0) \n        aln_force = Vect(0.0,0.0,0.0)\n        num = 0\n        for nbr in nbrs\n            num+=1\n            vec = nbr.pos - boid.pos\n            coh_force += vec\n            if veclength(vec)< model.parameters.min_dis\n                sep_force -= vec\n            end\n            aln_force += nbr.vel\n        end\n        aln_force = num>0 ? (aln_force / num - boid.vel) * model.parameters.aln_fac : aln_force\n        num = max(1, num)\n        coh_force *= (model.parameters.coh_fac/num)\n        sep_force *=  model.parameters.sep_fac\n        boid.vel  += (coh_force + sep_force) + aln_force\n        boid.vel  /= (veclength(boid.vel) + ep)\n        boid.orientation = boid.vel\n        boid.pos += boid.vel*dt\n    end\nend\n\nrun_model!(model, steps=500, step_rule = step_rule!)","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"animate_sim(model)","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"(Image: png)","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[(:min_dis, :s, 0.01:0.1:1.0),\n        (:coh_fac, :s, 0.01:0.01:1.0),\n        (:sep_fac, :s, 0.01:0.01:1.0),\n        (:aln_fac, :s, 0.01:0.01:1.0),\n        (:vis_range, :s, 0.5:0.5:4.0)], frames=400) ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"(Image: png)","category":"page"},{"location":"boids3d/#Step-4:-Fetch-Data","page":"Flocking","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"It is easy to fetch any data recorded during simulation. For example, the data of average velocity of agents at each time step can be obtained as - ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"df = get_agents_avg_props(model, agent -> agent.vel, labels = [\"average velocity\"])","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"boids3d/","page":"Flocking","title":"Flocking","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"schelling3d/#Schelling-segregation-model","page":"Schellings Segregation model","title":"Schelling segregation model","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"using EasyABM","category":"page"},{"location":"schelling3d/#Step-1:-Create-Agents-and-Model","page":"Schellings Segregation model","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"Lets create 200 agents with properties pos, mood and color. The keeps_record_of argument is list of properties that the agent will record during time evolution. The min_alike property of the model which specifies the minimum number of alike neighbors for an agent to be happy, is set to be 8. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"@enum agentsfeeling happy sad\nagents = grid_3d_agents(200, pos = Vect(1,1,1), color = :red, mood = happy, keeps_record_of=[:pos, :mood])\nmodel = create_3d_model(agents, agents_type = Static, space_type = NPeriodic, size = (7,7,7), min_alike = 8)","category":"page"},{"location":"schelling3d/#Step-2:-Initialise-the-model","page":"Schellings Segregation model","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"In the second step we initialise the agents by defining initialiser! function and then sending it as an argument to init_model!. In the initialiser! function we randomly set agents color to be either :red or :green and set their positions randomly such that there is not more than one agent on each patch. Then we set the mood property of each agent to be happy or sad depending upon the number of alike agents in neighborhood. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"function initialiser!(model)\n    for agent in model.agents\n        agent.color = [:red, :green][rand(1:2)]\n        x,y,z = random_empty_patch(model) \n        agent.pos = Vect(x, y, z)     \n    end    \n    for agent in model.agents\n        nbrs = grid_neighbors(agent, model, 1)\n        num_same = 0\n        for nbr in nbrs\n            if nbr.color == agent.color\n                num_same += 1\n            end\n        end\n        if num_same < model.parameters.min_alike\n            agent.mood = sad\n        end\n    end\nend\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"schelling3d/#Step-3:-Run-the-model","page":"Schellings Segregation model","title":"Step 3: Run the model","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"In this step we implement the step logic of the Schelling's model in the step_rule! function and run the model for 200 steps. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"function step_rule!(model)\n    min_alike = model.parameters.min_alike\n    for agent in model.agents\n        num_alike = 0\n        for nbr in grid_neighbors(agent, model,1)\n            if agent.color == nbr.color\n                num_alike += 1\n            end\n        end\n        if num_alike ≥ min_alike\n            agent.mood = happy\n        else\n            agent.mood = sad\n            x,y,z = random_empty_patch(model) \n            agent.pos = Vect(x, y, z)\n        end\n    end\n    return\nend\n\nrun_model!(model, steps=200, step_rule = step_rule!)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"animate_sim(model)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"(Image: png)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule=step_rule!,\n    model_controls=[(:min_alike, :s, 1:12)], \n    agent_plots=Dict(\n        \"happy\"=> agent-> agent.mood == happy, \n        \"sad\"=> agent-> agent.mood == sad),\n    frames=200)  \n","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"(Image: png)","category":"page"},{"location":"schelling3d/#Step-4:-Fetch-Data","page":"Schellings Segregation model","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"In this step we fetch data of number of happy and sad agents at each time step as a dataframe with following function. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"df = get_nums_agents(model, agent-> agent.mood == happy, agent-> agent.mood == sad,labels=[\"happy\",\"sad\"], plot_result=true)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"(Image: png)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation model","title":"Schellings Segregation model","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"ising/#Ising-model","page":"Ising model","title":"Ising model","text":"","category":"section"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"We use Ising model as an example of using Graph Models in EasyABM. We will set up and run Ising model on a grid graph, however one can choose graph of any other  topology as well.","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"using EasyABM","category":"page"},{"location":"ising/#Step-1:-Create-Model","page":"Ising model","title":"Step 1: Create Model","text":"","category":"section"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"In this model we will work solely with the graph and won't require agents. We create a grid graph of size 20x20, and then create our graph model as follows. ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"graph = square_grid_graph(20,20); \nmodel = create_graph_model(graph, temp = 0.1, coupl = 1.0)","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"The model has two parameters temperature temp and coupling coupl. ","category":"page"},{"location":"ising/#Step-2:-Initialise-the-model","page":"Ising model","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"In the second step we initialise the nodes of the graph through initialiser! function and then sending it as an argument to init_model!. In the initialiser! function we randomly set each node's color to either :black or :white and set their spin values to +1 for :black nodes and -1 for :white nodes. In the init_model! function the argument props_to_record specifies the nodes properties which we want to record during model run. ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"function initialiser!(model)\n    for node in model.graph.nodes\n        if rand()<0.5\n            model.graph.nodesprops[node].spin = 1\n            model.graph.nodesprops[node].color = :black\n        else\n            model.graph.nodesprops[node].spin = -1\n            model.graph.nodesprops[node].color = :white\n        end\n    end\nend\n\ninit_model!(model, initialiser = initialiser!, props_to_record = Dict(\"nodes\"=>[:color, :spin]))","category":"page"},{"location":"ising/#Step-3:-Run-the-model","page":"Ising model","title":"Step 3: Run the model","text":"","category":"section"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"In this step we implement the step logic of the Ising model in the step_rule! function and run the model for 200 steps. At each step of the simulation we take  100 Monte Carlo steps, where in each Monte Carlo step a node is selected at random and its spin and color values are flipped if the Ising energy condition is satisfied. ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"const nn = num_nodes(model) \n\nfunction step_rule!(model)\n    for i in 1:100\n        random_node = rand(1:nn)\n        spin = model.graph.nodesprops[random_node].spin\n        nbr_nodes = neighbor_nodes(random_node, model)\n        de = 0.0\n        for node in nbr_nodes\n            nbr_spin = model.graph.nodesprops[node].spin\n            de += spin*nbr_spin\n        end\n        de = 2*model.parameters.coupl * de\n        if (de < 0) || (rand() < exp(-de/model.parameters.temp))\n            model.graph.nodesprops[random_node].spin = - spin\n            model.graph.nodesprops[random_node].color = spin == -1 ? :black : :white\n        end\n    end\nend\n\nrun_model!(model, steps=200, step_rule = step_rule! )","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"animate_sim(model)","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"(Image: png)","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"Note that the scale slider is for changing the size of agents. As we have zero agents in the current model, this slider won't do anything. ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"create_interactive_app(model, initialiser= initialiser!,\n    props_to_record = Dict(\"nodes\"=>[:color, :spin]),\n    step_rule= step_rule!,\n    model_controls=[(:temp, :s, 0.05:0.05:5), (:coupl, :s, 0.01:0.1:5)],\n    node_plots = Dict(\"magnetisation\"=> x -> x.spin),\n    frames=200) ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"(Image: png)","category":"page"},{"location":"ising/#Step-4:-Fetch-Data","page":"Ising model","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"In this step we fetch the data of average spin of nodes (also called magnetisation) and plot the result as follows. ","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"df = get_nodes_avg_props(model, node -> node.spin, labels=[\"magnetisation\"], plot_result = true)","category":"page"},{"location":"ising/","page":"Ising model","title":"Ising model","text":"(Image: png)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = EasyABM","category":"page"},{"location":"#EasyABM.jl","page":"Introduction","title":"EasyABM.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A lightweight and easy to use framework for agent-based modelling. ","category":"page"},{"location":"#Package-Features","page":"Introduction","title":"Package Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Intuitive function based approach for all ABM modelling tasks. \nSupport for Hetrogeneous agents, where each agent can record its own properties. \nGrid blocks, called patches, in 2d and 3d models can be assigned properties like agents.\nNodes and edges in a graph based model can also be assigned properties like agents. \nUnderlying Graph in a graph model can be chosen to be fully dynamic in which edges and nodes can be added or removed during model run.\nEasy to create and save animation.\nLive interactive panel can also be easily created in Jupyter in a few lines of code. ","category":"page"},{"location":"conwaygol/#Conway's-Game-of-Life","page":"Conways Game of Life","title":"Conway's Game of Life","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"using EasyABM","category":"page"},{"location":"conwaygol/#Step-1:-Create-Agents-and-Model","page":"Conways Game of Life","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"We work with only patches in this model. The size of the  grid in the model created is 20x20 and alive_percent is the fraction of patches that are live initially.","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"model = create_2d_model(size = (20,20), alive_percent = 0.4)","category":"page"},{"location":"conwaygol/#Step-2:-Initialise-the-model","page":"Conways Game of Life","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"In the second step we initialise the agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we randomly set patches to be either of color :green or :white. The patches with green color have their  is_alive property set to true and the patches with white color have their is_alive property set to false. We specify the patch properties color and is_alive that we want to be recorded during time evolution in the props_to_record argument to the init_model! function.","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"function initialiser!(model)\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            if rand()<model.parameters.alive_percent\n                model.patches[i,j].color = :green\n                model.patches[i,j].is_alive = true\n            else\n                model.patches[i,j].color = :white\n                model.patches[i,j].is_alive = false\n            end\n        end\n    end\nend\n\ninit_model!(model, initialiser = initialiser!, \n    props_to_record=Dict(\"patches\"=>[:color, :is_alive]))","category":"page"},{"location":"conwaygol/#Step-3:-Run-the-model","page":"Conways Game of Life","title":"Step 3: Run the model","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"In this step we implement the step logic of the Conway's Game of Life in the step_rule! function and run the model for 100 steps.  Since Conway's model requires all patches to be updated at the same time, in the step_rule! function we first compute the is_alive  property for all patches and then apply it to patches.","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"function calculate_vals(model)\n    vals = [false for i in 1:model.size[1], j in 1:model.size[2]]\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            patch = model.patches[i,j]\n            nbrs = neighbor_patches((i,j), model, 1)\n            num_alive = 0\n            for nbr in nbrs\n                num_alive+= model.patches[nbr...].is_alive\n            end\n            condition1 = patch.is_alive && ((num_alive == 2) || (num_alive == 3))\n            condition2 = patch.is_alive && (num_alive == 3)\n            if condition1 || condition2\n                vals[i,j] = true\n            end\n        end\n    end\n    return vals\nend\n\nfunction apply_vals!(model, vals)\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            is_alive = vals[i,j]\n            model.patches[i,j].is_alive = is_alive\n            model.patches[i,j].color = is_alive ? :green : :white\n        end\n    end       \nend\n\n\nfunction step_rule!(model)\n    vals = calculate_vals(model)\n    apply_vals!(model, vals)\nend\n\nrun_model!(model, steps=100, step_rule = step_rule! )","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"animate_sim(model, show_grid=true)","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"(Image: png)","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[\n        (:alive_percent, :s, 0:0.01:1.0)\n        ], \n    frames=200, show_grid=true) ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"(Image: png)","category":"page"},{"location":"conwaygol/#Step-4:-Fetch-Data","page":"Conways Game of Life","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"We can fetch the data of number alive patches as follows. ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"df = get_nums_patches(model, patch-> patch.is_alive, labels=[\"Alive\"], \n    plot_result = true)","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"(Image: png)","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Studying an agents based model in EasyABM is basically a 4-step process. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create agents and model. \nInitialise the model, through an initialiser function.\nDefine a step_rule function and run the model. (After defining a step_rule one may also choose to explore the model through an interactive app.) \nFetch and analyse data collected during model run. (Or create visualisation based on data collected during model run).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We explain these steps below through a very simple model of a star-planet system. Though it can be debated if a star-planet system can really qualify as an agent based model, it nevertheless serves as a good example for demonstrating the workings of EasyABM. ","category":"page"},{"location":"tutorial/#Step-1:-Create-the-agents-and-the-model.","page":"Tutorial","title":"Step 1: Create the agents and the model.","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the first step we create the agents and the model. For the star-planet system, we need one agent for the star and one for the planet. We will assume that the star is stationary and the planet revolves around it. We set the position of the star to be Vect(5.0,5.0) which is the center point of the 2d space, as the default dimensions of 2d space in EasyABM is 10x10. The position pos is only accepted as a Vect which is an inbuilt vector type in EasyABM. It is also recommended for both convenience as well as performance to use Vect type for any vectorial properties in the model such as velocity and forces. We set the position of the planet to be Vect(7.0,5.0) and its velocity to be Vect(0.0,1.0). Since, the planet will change its position we require it to record its position and velocity during the model run. We specify this via keeps_record_of property of the planet. The gravity property of the model is a constant of proportionality for the force between the star and the planet. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"star = con_2d_agent( pos = Vect(5.0,5.0), size = 15, color = :yellow) # by default 2d space is 10x10, so that (5,5) is center.\nplanet = con_2d_agent(pos = Vect(7.0,5.0), vel = Vect(0.0,1.0), size=5, color = :blue, keeps_record_of = [:pos, :vel]) \nmodel = create_2d_model([star, planet], gravity = 3.0)","category":"page"},{"location":"tutorial/#Step-2:-Initialise-the-model.","page":"Tutorial","title":"Step 2: Initialise the model.","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this step we define an initialiser function to set the initial properties of the agents. Suppose we want our planet to be at position Vect(5.0,8.0) and velocity Vect(-1.0, 0.0) initially. We can do so by defining an initialiser function and then sending it as an argument to init_model! function as follows.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function initialiser!(model)\n    planet = model.agents[2]\n    planet.pos = Vect(5.0, 8.0)\n    planet.vel = Vect(-1.0,0.0)\nend\n\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"tutorial/#Step-3:-Define-a-step_rule-and-run-the-model","page":"Tutorial","title":"Step 3: Define a step_rule and run the model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this step, we define rule for the time evolution and then run the model. We define our step_rule to be simply discretisation of Newton's equations for a 2 body system.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function step_rule!(model)\n    gravity = model.parameters.gravity\n    star = model.agents[1]\n    planet = model.agents[2]\n    distance_vector = (star.pos - planet.pos)\n    distance = veclength(distance_vector)\n    force = gravity*distance_vector/distance^3\n    planet.vel += force\n    planet.pos+= planet.vel \nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can run the model for desired number of steps as follows","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"run_model!(model, steps = 200, step_rule = step_rule!)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once the model has run, we can look at the animation of the time evolution with following line of code","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"animate_sim(model)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: png)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The model can be saved to the disk as a jld2 file using following function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"save_model(model, model_name = \"sun_planet_model\", save_as = \"sun_planet.jld2\", folder = \"/path/to/folder/\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A model saved previously as jld2 file, can be fetched as follows ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"model = open_saved_model(model_name = \"sun_planet_model\", path = \"/path/to/folder/sun_planet.jld2\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Instead of first running the model, we can create an interactive app in Jupyter to explore the model by setting different values of parameters, as shown below. Here, the model_control argument is for creating a slider with values from 1 to 5 in steps of 0.2 for the model parameter gravity. The agent_controls argument creates a slider for the x component of planet's initial velocity. The tail argument attaches a tail of length 30 with the planet by selecting it with its color property which we previously set to :blue. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[(:gravity, :s, 1:0.2:5.0)], \n    agent_controls=[(:vel, :s, [Vect(x, 0.0) for x in -10.0:0.1:5.0])],\n    frames=200, tail = (30, agent -> agent.color == :blue)) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: png)","category":"page"},{"location":"tutorial/#Step-4:-Fetch-data","page":"Tutorial","title":"Step 4: Fetch data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this simple model, the only data we have collected is the position and velocity of the planet. We can get this data as follows. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df = get_agent_data(model.agents[2], model).record","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The following line of code returns the data of (half of the) speed of the planet during time evolution.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df = get_agents_avg_props(model, agent -> agent.color == :blue ? veclength(agent.vel) : 0.0, labels = [\"Planet Speed/2\"], plot_result = true)   ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: png)","category":"page"}]
}
