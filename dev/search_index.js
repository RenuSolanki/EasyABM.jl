var documenterSearchIndex = {"docs":
[{"location":"NNSIsing/#Ising-model-on-a-nearest-neighbor-random-graph","page":"Ising on a nearest neighbor graph","title":"Ising model on a nearest neighbor random graph","text":"","category":"section"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"This is another example including Ising model where the underlying graph is a random nearest neighbor graph on plane. ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"using EasyABM","category":"page"},{"location":"NNSIsing/#Step-1:-Create-Model","page":"Ising on a nearest neighbor graph","title":"Step 1: Create Model","text":"","category":"section"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"In this model we will work solely with the graph and won't need agents. We initially create an empty graph, and then create our model as follows. ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"graph = dynamic_simple_graph(0) # in a dynamic graph nodes and edges can be added or deleted. \nmodel = create_graph_model(graph, temp = 2.0, coupl = 2.5, nns = 5)","category":"page"},{"location":"NNSIsing/#Step-2:-Initialise-the-model","page":"Ising on a nearest neighbor graph","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"In the initialiser! function we create a list of n = 500 random points in the plane and fill our graph with n nodes and set the position of ith node to the ith random point. We then link each node to its nns number of nearest neighbors and randomly set each node's color to either cl\"black\" or cl\"white\" and set spin value to +1 for cl\"black\" nodes and -1 for cl\"white\" nodes. In the init_model! function, the argument props_to_record specifies the nodes properties which we want to record during model run. ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"using NearestNeighbors","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"const n=500;","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"vecs = rand(2, n) .* 10\nkdtree = KDTree(vecs,leafsize=4)\n    \nfunction initialiser!(model)\n    flush_graph!(model) # deletes all nodes and edges\n    add_nodes!(n, model, color = cl\"black\", spin =1) # adds n nodes to model's graph with all the nodes having color black and spin 1\n    for i in 1:n \n        model.graph.nodesprops[i].pos = (vecs[1,i], vecs[2,i]) # set positions of nodes in the 2d plane\n        indices, _ = knn(kdtree, vecs[:,i], model.parameters.nns, true) # indices of nearest neighboring vectors\n        for j in indices\n            if j!=i\n                create_edge!(i,j, model)\n            end\n        end\n        if rand()<0.5\n            model.graph.nodesprops[i].spin = 1\n            model.graph.nodesprops[i].color = cl\"black\"\n        else\n            model.graph.nodesprops[i].spin = -1\n            model.graph.nodesprops[i].color = cl\"white\"\n        end\n    end\nend","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"init_model!(model, initialiser= initialiser!, props_to_record = Dict(\"nodes\"=>Set([:color, :spin])))","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"draw_graph(model.graph)","category":"page"},{"location":"NNSIsing/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Ising on a nearest neighbor graph","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"In this step we implement the step logic of the Ising model in the step_rule! function and run the model for 100 steps. At each step of the simulation we take 100 Monte Carlo steps, where in each Monte Carlo step a node is selected at random and its spin and color values are flipped if the Ising energy condition is satisfied. ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"function step_rule!(model)\n    for i in 1:100\n        random_node = rand(1:n)\n        spin = model.graph.nodesprops[random_node].spin\n        nbr_nodes = neighbor_nodes(random_node, model)\n        de = 0.0\n        for node in nbr_nodes\n            nbr_spin = model.graph.nodesprops[node].spin\n            de += spin*nbr_spin\n        end\n        de = 2*model.parameters.coupl * de\n        if (de < 0) || (rand() < exp(-de/model.parameters.temp))\n            model.graph.nodesprops[random_node].spin = - spin\n            model.graph.nodesprops[random_node].color = spin == -1 ? cl\"black\" : cl\"white\"\n        end\n    end\nend","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"run_model!(model, steps = 100, step_rule = step_rule!)","category":"page"},{"location":"NNSIsing/#Step-4:-Visualisation","page":"Ising on a nearest neighbor graph","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"In order to draw the model at a specific frame, say 4th, one can use draw_frame(model, frame = 4).  If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"animate_sim(model)","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"(Image: png)","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"create_interactive_app(model, initialiser= initialiser!,\n    props_to_record = Dict(\"nodes\"=>Set([:color, :spin])),\n    step_rule= step_rule!,\n    model_controls=[(:temp, \"slider\", 0.05:0.05:5.0), \n        (:coupl, \"slider\", 0.01:0.1:5.0),\n        (:nns, \"slider\", 2:10)],\n    node_plots = Dict(\"magnetisation\"=> x -> x.spin),\n    frames=100) ","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"(Image: png)","category":"page"},{"location":"NNSIsing/#Step-4:-Fetch-Data","page":"Ising on a nearest neighbor graph","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"In this step we fetch the data of average spin of nodes (also called magnetisation) and plot the result as follows.","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"df = get_nodes_avg_props(model, node -> node.spin, labels=[\"magnetisation\"], plot_result = true)","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"(Image: png)","category":"page"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"","category":"page"},{"location":"NNSIsing/#References","page":"Ising on a nearest neighbor graph","title":"References","text":"","category":"section"},{"location":"NNSIsing/","page":"Ising on a nearest neighbor graph","title":"Ising on a nearest neighbor graph","text":"https://en.wikipedia.org/wiki/Ising_model","category":"page"},{"location":"ElemCA/#Elementary-cellular-automaton","page":"Elementary Cellular Automaton","title":"Elementary cellular automaton","text":"","category":"section"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"using EasyABM","category":"page"},{"location":"ElemCA/#Step-1:-Create-Model","page":"Elementary Cellular Automaton","title":"Step 1: Create Model","text":"","category":"section"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"In this model, we work with patches only. We set grid_size to (50,50) and set space_type to NPeriodic. ","category":"page"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"model = create_2d_model(size = (50,50), space_type=NPeriodic)","category":"page"},{"location":"ElemCA/#Step-2:-Initialise-the-model","page":"Elementary Cellular Automaton","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"We assign two attributes namely color and val to all patches. The patches with val 0 are white while those with val 1 are black. Initially, we set all patches to have val = 0, color = cl\"white\" except for the patch at position (25,1) which is assigned val = 1, color = cl\"black\". Since, the color and val attributes are not independent, we tell EasyABM to record only color attribute of the patches through the argument props_to_record to the init_model! function. ","category":"page"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"function initialiser!(model)\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            model.patches[i,j].color = cl\"white\"\n            model.patches[i,j].val = 0\n        end\n    end\n    model.patches[25,1].color = cl\"black\"\n    model.patches[25,1].val = 1\nend\n\ninit_model!(model, initialiser = initialiser!, props_to_record = Dict(\"patches\" => Set([:color])))   ","category":"page"},{"location":"ElemCA/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Elementary Cellular Automaton","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"The dictionary rules defines the update rule. It is known as rule number 30 in the classification of elementary cellular automata. The val property (and hence the color) of jth patch in (i+1)th row is set equal to the value in rules corresponding to the key (a, b, c) where in the ith row a is val of (j-1)th patch, b is val of jth patch and c is the val of (j+1)th patch. Since the size of our space is finite, after a certain number of iterations we have to copy each row to the row below and update the topmost row.  ","category":"page"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"rules = Dict((1,1,1)=>0, (1,1,0)=>0, (1,0,1)=>0, (0,1,1)=>1, \n(1,0,0)=>1, (0,1,0)=>1, (0,0,1)=>1, (0,0,0)=>0) # rule 30\n\n\nfunction update_from_row_below(row, model)\n    for j in 2:(model.size[1]-1)\n        vals = (model.patches[j-1, row-1].val, \n                model.patches[j,   row-1].val, \n                model.patches[j+1, row-1].val)   \n        val = rules[vals]\n        model.patches[j, row].val = val\n        model.patches[j, row].color = val==0 ? cl\"white\" : cl\"black\"\n    end\nend\n\nfunction copy_to_row_below(row, model)\n    for j in 1:model.size[1]\n        model.patches[j, row-1].val = model.patches[j, row].val\n        model.patches[j, row-1].color = model.patches[j, row].color\n    end\nend\n\nfunction step_rule!(model)\n    if model.tick < model.size[1]\n        row = model.tick+1\n        update_from_row_below(row, model)      \n    else\n        for i in 2:model.size[1]\n            copy_to_row_below(i, model)\n        end\n        update_from_row_below(model.size[1], model)\n    end\n        \nend","category":"page"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"runmodel!(model, steps = 200, steprule = step_rule!)","category":"page"},{"location":"ElemCA/#Step-4:-Visualisation","page":"Elementary Cellular Automaton","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"In order to draw the model at a specific frame, say 4th, one can use draw_frame(model, frame = 4 ). If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"animate_sim(model)","category":"page"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"(Image: png)","category":"page"},{"location":"ElemCA/#Step-5:-Fetch-Data","page":"Elementary Cellular Automaton","title":"Step 5: Fetch Data","text":"","category":"section"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"It is easy to fetch any recorded data after running the model. For example, the numbers of patches with color cl\"white\" can be got as follows","category":"page"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"df = get_nums_patches(model, \n    patch-> patch.color == cl\"white\", \n    labels=[\"white\"], plot_result=true)","category":"page"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"(Image: png)","category":"page"},{"location":"ElemCA/#References","page":"Elementary Cellular Automaton","title":"References","text":"","category":"section"},{"location":"ElemCA/","page":"Elementary Cellular Automaton","title":"Elementary Cellular Automaton","text":"https://en.wikipedia.org/wiki/Elementarycellularautomaton","category":"page"},{"location":"tips/","page":"Do's and Don'ts","title":"Do's and Don'ts","text":"warn: Warn\nAvoid modifying any mutable model properties except through using utility functions provided in EasyABM. For example, shuffling the list model.agents may lead to errorneous results. Immutable properties like model.tick must also be not modified as they are only for internal use in EasyABM.","category":"page"},{"location":"tips/","page":"Do's and Don'ts","title":"Do's and Don'ts","text":"tip: Performance Tips\nAvoid using global variables (its a general tip for Julia users)\nIn EasyABM the types of model properties and agents properties other than position are not declared while defining the model. Therefore, if the user wishes to make code a bit more performant, these properties can be annotated with their types in the step_rule! function.","category":"page"},{"location":"abelian_sandpile/#Abelian-Sandpile","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"","category":"section"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"using EasyABM","category":"page"},{"location":"abelian_sandpile/#Step-1:-Create-Model","page":"Abelian Sandpile","title":"Step 1: Create Model","text":"","category":"section"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"In this model, we work with patches only. We set grid_size to (50,50), set space_type to NPeriodic and define an additional model parameter threshold whose value is set to 4. ","category":"page"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"model = create_2d_model(size = (50,50), space_type=NPeriodic, threshold = 4)","category":"page"},{"location":"abelian_sandpile/#Step-2:-Initialise-the-model","page":"Abelian Sandpile","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"Initially, we set the amount of sand on all patches equal to 2 except for the patch (25,25) where we set the sand amount to value 2000. The color attribute of patches is set according to the amount of sand they carry. If the sand amound on a patch is >=4 then its color is blue, otherwise the color is set according to dictionary coldict. ","category":"page"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"const coldict = Dict(0=>cl\"white\", 1=>cl\"yellow\", 2=>cl\"green\", 3=> cl\"orange\", 4=>cl\"red\")\n\nfunction initialiser!(model)\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            model.patches[i,j].sand = 2\n            model.patches[i,j].color= coldict[2]\n        end\n    end\n    model.patches[25,25].sand = 2000\n    model.patches[25,25].color= cl\"blue\"\nend\n\ninit_model!(model, initialiser = initialiser!, props_to_record = Dict(\"patches\" => Set([:color,:sand])))","category":"page"},{"location":"abelian_sandpile/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Abelian Sandpile","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"In the step function we loop over all the patches and if a patch has sand >= 4, we topple that patch which means that i) We reduce the amount of sand on that patch by 4 ii) We increase the amount of sand on its Von Neumann neighboring patches by 1. ","category":"page"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"\nfunction topple!(patch_loc, model, threshold)\n    nbr_patch_locs = neighbor_patches_neumann(patch_loc, model, 1)\n    for p in nbr_patch_locs\n        pth_patch = model.patches[p...]\n        sand = pth_patch.sand + 1\n        pth_patch.sand = sand\n        pth_patch.color = sand <= 4 ? coldict[sand] : cl\"blue\" \n    end\n    patch = model.patches[patch_loc...]\n    sand = patch.sand-threshold\n    patch.sand = sand\n    patch.color = sand <= 4 ? coldict[sand] : cl\"blue\" \nend\n\nfunction step_rule!(model)\n    threshold = model.parameters.threshold\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            if model.patches[i,j].sand>=threshold\n                topple!((i,j),model, threshold)\n            end\n        end\n    end\nend\n\nrun_model!(model, steps = 1000, step_rule = step_rule!)","category":"page"},{"location":"abelian_sandpile/#Step-4:-Visualisation","page":"Abelian Sandpile","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"In order to draw the model at a specific frame, say 4th, one can use draw_frame(model, frame = 4 ). If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"animate_sim(model)","category":"page"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"(Image: png)","category":"page"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"create_interactive_app(model, initialiser= initialiser!,\n    props_to_record = Dict(\"patches\" => Set([:color])),\n    model_controls = [(:threshold, \"slider\", 1:10)],\n    step_rule= step_rule!,frames=500, show_patches=true) ","category":"page"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"(Image: png)","category":"page"},{"location":"abelian_sandpile/#Step-5:-Fetch-Data","page":"Abelian Sandpile","title":"Step 5: Fetch Data","text":"","category":"section"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"It is easy to fetch any recorded data after running the model. For example, the numbers of patches with different amounts of sand at all timesteps can be got as follows","category":"page"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"df = get_nums_patches(model, \n    patch-> patch.sand == 0, \n    patch-> patch.sand == 1, \n    patch-> patch.sand == 2, \n    patch-> patch.sand == 3,\n    labels=[\"sand=0\",\"sand=1\",\"sand=2\",\"sand=3\"], plot_result=true)","category":"page"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"(Image: png)","category":"page"},{"location":"abelian_sandpile/#References","page":"Abelian Sandpile","title":"References","text":"","category":"section"},{"location":"abelian_sandpile/","page":"Abelian Sandpile","title":"Abelian Sandpile","text":"1.) https://en.wikipedia.org/wiki/Abeliansandpilemodel","category":"page"},{"location":"predator_prey/#Predator-prey-model","page":"Predator-prey","title":"Predator-prey model","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"using EasyABM","category":"page"},{"location":"predator_prey/#Step-1:-Create-Agents-and-Model","page":"Predator-prey","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"We create 200 agents all of type sheep to begin with. Our model parameters are ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"max_energy : The maximum energy that an agent (sheep or wolf) can have. \nwolf_birth_rate : Probability of a wolf agent to reproduce once its energy is greater than max_energy/2.  \nsheep_birth_rate : Probability of a sheep agent to reproduce once its energy is greater than max_energy/2. \nwolves_kill_ability : The probability of a wolf to kill a neighboring sheep.\ngrass_grow_prob : The probability of one unit of grass growing on a patch at a given timestep.\nmax_grass : Max grass a patch can have.\ninitial_wolf_percent : The percent of agents which are wolf initially. ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"@enum agenttype sheep wolf\nagents = grid_2d_agents(200, pos = Vect(1,1), color = cl\"white\", atype = sheep, \n    energy = 10.0, keeps_record_of=Set([:pos, :energy ]))\nmodel = create_2d_model(agents, \n    size = (20,20), #space size\n    agents_type = Mortal, # agents are mortal, can take birth or die\n    space_type = NPeriodic, # nonperiodic space\n    # below are all the model parameters\n    max_energy = 50, \n    wolf_birth_rate = 0.01,\n    sheep_birth_rate = 0.1,\n    wolves_kill_ability = 0.2,\n    max_grass = 5,\n    initial_wolf_percent = 0.2,\n    grass_grow_prob = 0.2)","category":"page"},{"location":"predator_prey/#Step-2:-Initialise-the-model","page":"Predator-prey","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"In the second step we initialise the patches and agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we randomly set amount of grass and accordingly color of each patch. We also set a fraction initial_wolf_percent of agents to be of type wolf. We set color of sheeps to white and that of wolves to black. We also randomly set the energy and positions of agents. In the init_model! function through argument props_to_record we tell EasyABM to record the color property of patches during model run. ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"function initialiser!(model)\n    max_grass = model.parameters.max_grass\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            grass = rand(1:max_grass)\n            model.patches[i,j].grass = grass\n            hf = Int(ceil(max_grass/2))\n            model.patches[i,j].color = grass > hf ? cl\"green\" : (grass > 0 ? cl\"blue\" : cl\"grey\")\n        end\n    end\n    for agent in model.agents\n        if rand()< model.parameters.initial_wolf_percent \n            agent.atype = wolf\n            agent.color = cl\"black\"\n        else\n            agent.atype = sheep\n            agent.color = cl\"white\"\n        end\n        agent.energy = rand(1:model.parameters.max_energy)+0.0\n        agent.pos = Vect(rand(1:model.size[1]), rand(1:model.size[2]))\n    end\n            \nend\n\ninit_model!(model, initialiser = initialiser!, props_to_record = Dict(\"patches\"=>Set([:color])))","category":"page"},{"location":"predator_prey/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Predator-prey","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"In this step we implement the step logic of the predator prey model in the step_rule! function and run the model for 100 steps. ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"function change_pos!(agent)\n    dx = rand(-1:1)\n    dy = rand(-1:1)\n    agent.pos += Vect(dx, dy)\nend\n\nfunction reproduce!(agent, model)\n    new_agent = create_similar(agent)\n    agent.energy = agent.energy/2\n    new_agent.energy = agent.energy\n    add_agent!(new_agent, model)\nend\n\nfunction eat_sheep!(wolf, sheep, model)\n    kill_agent!(sheep, model) \n    wolf.energy+=1\nend\n\n\nfunction act_asa_wolf!(agent, model)\n    if !(is_alive(agent))\n        return\n    end\n    energy = agent.energy\n    if energy > 0.5*model.parameters.max_energy\n        if rand()<model.parameters.wolf_birth_rate\n            reproduce!(agent, model)\n        end\n    elseif energy > 0 \n        nbrs = collect(neighbors_moore(agent, model, 1))\n        n = length(nbrs)\n        if n>0\n            nbr = nbrs[rand(1:n)]\n            if (nbr.atype == sheep)&&(is_alive(nbr))\n                ability = model.parameters.wolves_kill_ability\n                (rand()<ability)&&(eat_sheep!(agent, nbr, model))\n            end\n        end\n        change_pos!(agent)\n    else\n        kill_agent!(agent, model)\n    end\nend\n\nfunction act_asa_sheep!(agent, model)\n    if !(is_alive(agent))\n        return\n    end\n    energy = agent.energy\n    if energy >0.5* model.parameters.max_energy\n        if rand()<model.parameters.sheep_birth_rate\n            reproduce!(agent, model)\n        end\n        change_pos!(agent)\n    elseif energy > 0 \n        patch = get_grid_loc(agent)\n        grass = model.patches[patch...].grass\n        if grass>0\n            model.patches[patch...].grass-=1\n            agent.energy +=1\n        end\n        change_pos!(agent)\n    else\n        kill_agent!(agent, model)\n    end\nend\n\n\n\nfunction step_rule!(model)\n    if model.max_id>800 # use some upper bound on max agents to avoid system hang\n        return\n    end\n    for agent in model.agents\n        if agent.atype == wolf\n            act_asa_wolf!(agent,model)\n        end\n        if agent.atype == sheep\n            act_asa_sheep!(agent, model)\n        end\n    end\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            patch = model.patches[i,j]\n            grass = patch.grass\n            max_grass = model.parameters.max_grass \n            if grass < max_grass\n                if rand()<model.parameters.grass_grow_prob\n                    patch.grass+=1\n                    hf = Int(ceil(max_grass/2))\n                    patch.color = grass > hf ? cl\"green\" : (grass > 0 ? cl\"yellow\" : cl\"grey\")\n                end\n            end\n        end\n    end\nend\n\nrun_model!(model, steps=100, step_rule = step_rule! )","category":"page"},{"location":"predator_prey/#Step-4:-Visualisation","page":"Predator-prey","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"In order to draw the model at a specific frame, say 4th, one can use draw_frame(model, frame = 4, show_patches=true). If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"animate_sim(model, show_patches=true)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"(Image: png)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[\n        (:wolf_birth_rate, \"slider\", 0:0.01:1.0),\n        (:sheep_birth_rate, \"slider\", 0.01:0.01:1.0),\n        (:initial_wolf_percent, \"slider\", 0.01:0.01:0.9),\n        (:wolves_kill_ability, \"slider\", 0.01:0.01:1.0),\n        (:grass_grow_prob, \"slider\", 0.01:0.01:0.5)\n        ], \n    agent_plots=Dict(\"sheep\"=> agent-> agent.atype == sheep ? 1 : 0, \n        \"wolf\"=> agent-> agent.atype == wolf ? 1 : 0),\n    frames=200, show_patches=true)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"(Image: png)","category":"page"},{"location":"predator_prey/#Step-4:-Fetch-Data","page":"Predator-prey","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"We can fetch the number of wolves and sheeps at each time step as follows. ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"df = get_nums_agents(model, agent-> agent.atype == sheep, \n    agent->agent.atype == wolf, labels=[\"Sheep\", \"Wolf\"], \n    plot_result = true)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"(Image: png)","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"predator_prey/#References","page":"Predator-prey","title":"References","text":"","category":"section"},{"location":"predator_prey/","page":"Predator-prey","title":"Predator-prey","text":"Wilensky, U. (1997). NetLogo Wolf Sheep Predation model. http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation. Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.","category":"page"},{"location":"schelling/#Schelling-segregation-model","page":"Schellings Segregation 2D","title":"Schelling segregation model","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"using EasyABM","category":"page"},{"location":"schelling/#Step-1:-Create-Agents-and-Model","page":"Schellings Segregation 2D","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"Lets create 200 agents with properties pos, mood and color. The keeps_record_of argument is list of properties that the agent will record during time evolution. The min_alike property of the model which specifies the minimum number of alike neighbors for an agent to be happy, is set to be 4. ","category":"page"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"@enum agentsfeeling happy sad\nagents = grid_2d_agents(200, pos = Vect(1,1), color = cl\"green\", mood = happy, keeps_record_of=Set([:pos, :mood]))\nmodel = create_2d_model(agents, agents_type = Static, space_type=NPeriodic, size = (20,20), min_alike = 4)","category":"page"},{"location":"schelling/#Step-2:-Initialise-the-model","page":"Schellings Segregation 2D","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"In the second step we initialise the agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we randomly set agents color to be either cl\"red\" or cl\"green\" and set their positions randomly such that there is not more than one agent on each patch. Then we set the mood property of each agent to be happy or sad depending upon the number of alike agents in neighborhood. ","category":"page"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"function initialiser!(model)\n    min_alike = model.parameters.min_alike\n    for agent in model.agents\n        agent.color = [cl\"red\", cl\"green\"][rand(1:2)]\n        x,y = random_empty_patch(model)   \n        agent.pos = Vect(x,y)\n    end    \n    for agent in model.agents\n        nbrs = neighbors_moore(agent, model, 1)\n        num_alike = 0\n        for nbr in nbrs\n            if nbr.color == agent.color\n                num_alike += 1\n            end\n        end\n        if num_alike < min_alike\n            agent.mood = sad\n        end\n    end\nend\n\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"schelling/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Schellings Segregation 2D","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"In this step we implement the step logic of the Schelling's model in the step_rule! function and run the model for 200 steps. ","category":"page"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"function step_rule!(model)\n    min_alike = model.parameters.min_alike\n    for agent in model.agents\n        count_alike = 0\n        for nbr in neighbors_moore(agent, model,1)\n            if agent.color == nbr.color\n                count_alike += 1\n            end\n        end\n        if count_alike ≥ min_alike\n            agent.mood = happy\n        else\n            agent.mood = sad\n            x,y = random_empty_patch(model) \n            agent.pos = Vect(x,y)\n        end\n    end\n    return\nend\n\nrun_model!(model, steps=200, step_rule = step_rule! )","category":"page"},{"location":"schelling/#Step-4:-Visualisation","page":"Schellings Segregation 2D","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"In order to draw the model at a specific frame, say 4th, one can use draw_frame(model, frame = 4, show_patches=true). If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"animate_sim(model,agent_plots=Dict(\"happy\"=> agent-> agent.mood == happy, \"sad\"=> agent-> agent.mood == sad), show_patches=true)","category":"page"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"(Image: png)","category":"page"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"create_interactive_app(model, \n    initialiser= initialiser!,\n    step_rule=step_rule!,\n    model_controls=[(:min_alike, \"slider\", 1:8)], \n    agent_plots=Dict(\n        \"happy\"=> agent-> agent.mood == happy, \n        \"sad\"=> agent-> agent.mood == sad),\n    frames=200, show_patches=true) ","category":"page"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"(Image: png)","category":"page"},{"location":"schelling/#Step-5:-Fetch-Data","page":"Schellings Segregation 2D","title":"Step 5: Fetch Data","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"In this step we fetch data of number of happy and sad agents at each time step as a dataframe using following line of code. ","category":"page"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"df = get_nums_agents(model, \nagent-> agent.mood == happy, \nagent-> agent.mood == sad,\nlabels=[\"happy\",\"sad\"], \nplot_result=true)","category":"page"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"(Image: png)","category":"page"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"schelling/#References","page":"Schellings Segregation 2D","title":"References","text":"","category":"section"},{"location":"schelling/","page":"Schellings Segregation 2D","title":"Schellings Segregation 2D","text":"1.) https://en.wikipedia.org/wiki/Schelling%27smodelof_segregation","category":"page"},{"location":"nearest_neighbor_graph/#Nearest-neighbor-graph-generator","page":"Nearest Neighbor Graph","title":"Nearest neighbor graph generator","text":"","category":"section"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"We include the present model as an example of dynamic graphs in EasyABM.","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"using EasyABM","category":"page"},{"location":"nearest_neighbor_graph/#Step-1:-Create-Model","page":"Nearest Neighbor Graph","title":"Step 1: Create Model","text":"","category":"section"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"In this model we will work solely with the graph and won't require agents. We create a dynamic graph of n=500 vertices (and no edges) and create a model with this graph as base space. The model parameter nns is the number of nearest neighbors that each node will have edges with. ","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"n=500\ngraph = dynamic_simple_graph(n);  \nmodel = create_graph_model(graph, nns=10)","category":"page"},{"location":"nearest_neighbor_graph/#Step-2:-Initialise-the-model","page":"Nearest Neighbor Graph","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"In this model we use NearestNeighbors.jl package to produce a kdtree of points which will be used to get nearest neighbors in the step rule. We create a random 2xn matrix and initialise the positions of nodes with these vectors. ","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"vecs = rand(2, n).* 10;\n\nfunction initialiser!(model)\n    for i in 1:n\n        model.graph.nodesprops[i].pos = (vecs[1,i], vecs[2,i])\n    end\nend\n\ninit_model!(model, initialiser= initialiser!)","category":"page"},{"location":"nearest_neighbor_graph/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Nearest Neighbor Graph","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"In the step_rule! function we need to compute nearest neighbors of points for which we make use of NearestNeighbors.jl package.","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"using NearestNeighbors\nkdtree = KDTree(vecs,leafsize=4)\n\nfunction step_rule!(model)\n    if model.tick <=n\n        i = model.tick\n        indices, _ = knn(kdtree, vecs[:,i], model.parameters.nns, true)\n        for j in indices\n            if j!=i\n                create_edge!(i,j, model)\n            end\n        end\n    end  \nend\n\nrun_model!(model, steps=n, step_rule = step_rule! )","category":"page"},{"location":"nearest_neighbor_graph/#Step-3:-Visualisation","page":"Nearest Neighbor Graph","title":"Step 3: Visualisation","text":"","category":"section"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"In order to draw the model at a specific frame, say 4th, one can use draw_frame(model, frame = 4). If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"animate_sim(model)","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"(Image: png)","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"create_interactive_app(model, initialiser = initialiser!,\n    step_rule = step_rule!,\n    model_controls = [(:nns, \"slider\", 1:20)],\n    frames = n\n)","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"(Image: png)","category":"page"},{"location":"nearest_neighbor_graph/#Step-5:-Fetch-Data","page":"Nearest Neighbor Graph","title":"Step 5: Fetch Data","text":"","category":"section"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"In the present model we didn't record any data, however, since the model involved a dynamic graph the number of edges (and nodes) at each time step were recorded by default by EasyABM. We can get the data of number of edges at each time step as follows","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"df = get_nums_edges(model, edge-> true, labels=[\"num edges\"], plot_result = true)","category":"page"},{"location":"nearest_neighbor_graph/","page":"Nearest Neighbor Graph","title":"Nearest Neighbor Graph","text":"(Image: png)","category":"page"},{"location":"SIR/#SIR-model","page":"SIR model","title":"SIR model","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In the agent-based modeling approach an epidemiological model, like SIR model can have a large number of parameters depending upon the requirements. Below we will implement a basic SIR model in EasyABM.","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"using EasyABM","category":"page"},{"location":"SIR/#Step-1:-Create-Agents-and-Model","page":"SIR model","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In our SIR model there will be four type of agents - susceptible, infectious, recovered, dead. We assume that the recovered agents become immune and do not get infected again. We create 500 2d agents all of type agentS (later in the initilisation step will set the type of some agents to be agentI). The not_well_since property of an agent is the time since the agent got infected. Our model has parameters initially_sick (number of agents initially sick), sickness_duration (duration of sickness), infection_prob (probability of infection when an infected agent comes in contact with a susceptible agent) and death_prob (the probability of death from infection). ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"\n@enum agentstate begin\n    susceptible=1\n    infectious=2\n    recovered=3\n    dead=4\nend\n\nagents = grid_2d_agents(500, pos = Vect(1,1), color=cl\"green\", \n        atype = susceptible, not_well_since = 0, \n        keeps_record_of = Set([:atype, :color, :pos]));\n\nmodel = create_2d_model(agents, size=(50,50), \n        agents_type = Static, ## agents don't get removed from or added to the model\n        space_type = Periodic, initially_sick = 10, \n        sickness_duration = 21, infection_prob = 0.8, \n        death_prob=0.05);","category":"page"},{"location":"SIR/#Step-2:-Initialise-the-model","page":"SIR model","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In the second step we initialise the agents by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we set first initially_sick number of agents to be in infectious state and set their color to cl\"red\". All other agents are set to be in susceptible state with color cl\"green\". We also set each agents position at the center of a randomly selected patch.  ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"function initialiser!(model)\n    for (i,agent) in enumerate(model.agents)\n        if i<=model.parameters.initially_sick\n            agent.atype = infectious\n            agent.color = cl\"red\"\n        else \n            agent.atype = susceptible\n            agent.color = cl\"green\"\n        end\n        agent.not_well_since = 0 \n        x = rand(1:model.size[1])\n        y = rand(1:model.size[2])\n        agent.pos = Vect(x, y) # center of a random patch\n    end\nend\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"SIR/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"SIR model","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In this step we implement the step logic of the SIR model in the step_rule! function and run the model for 100 steps. ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"function die_or_recover(agent, death_prob)\n    if rand()<death_prob\n        agent.atype = dead\n        agent.color = cl\"black\"\n    else\n        agent.atype = recovered\n        agent.color = cl\"yellow\"\n    end\n    agent.not_well_since = 0 \nend\n\nfunction infect_neighbors(agent, nbrs, infection_prob)\n    for nbr in nbrs\n        if (nbr.atype ==susceptible) && (rand()< infection_prob)\n            nbr.atype = infectious\n            nbr.not_well_since = 0\n            nbr.color = cl\"red\"\n        end\n    end\nend\n\nfunction change_position(agent)\n    dx =rand(-1:1)\n    dy =rand(-1:1)\n    agent.pos += Vect(dx,dy)\nend\n\nfunction step_rule!(model)\n    parameters = model.parameters\n    for agent in model.agents\n        nbrs = neighbors_moore(agent, model, 1) #immediate neighbors on grid\n        if agent.atype == infectious\n             agent.not_well_since +=1\n            if agent.not_well_since > parameters.sickness_duration\n                die_or_recover(agent, parameters.death_prob)\n            elseif agent.not_well_since>1\n                infect_neighbors(agent, nbrs, parameters.infection_prob)\n            end   \n        end\n        if agent.atype !=dead\n            change_position(agent)\n        end   \n    end\nend\n\n\nrun_model!(model, steps=100, step_rule = step_rule! )","category":"page"},{"location":"SIR/#Step-4:-Visualisation","page":"SIR model","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"In order to draw the model at a specific frame, say 4th, one can use draw_frame(model, frame = 4). If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"animate_sim(model, \nagent_plots = Dict(\n        \"Susceptible\"=> ag -> ag.atype == susceptible ? 1 : 0, \n        \"Infected\" => ag -> ag.atype == infectious ? 1 : 0,\n        \"Recovered\" => ag -> ag.atype == recovered ? 1 : 0\n        ),\nshow_patches=true\n)","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"(Image: png)","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[(:initially_sick, \"slider\", 1:500), \n        (:sickness_duration, \"slider\", 5:25),\n        (:infection_prob, \"slider\", 0.01:0.01:1.0),\n        (:death_prob, \"slider\", 0.01:0.01:0.1)\n        ],\n    agent_plots = Dict(\"Susceptible\"=> ag -> ag.atype == susceptible ? 1 : 0, \n        \"Infected\" => ag -> ag.atype == infectious ? 1 : 0,\n        \"Recovered\" => ag -> ag.atype == recovered ? 1 : 0\n        ),\n    frames=70,\n    show_patches=true)   ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"(Image: png)","category":"page"},{"location":"SIR/#Step-5:-Fetch-Data","page":"SIR model","title":"Step 5: Fetch Data","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"The following line of code fetches data of average number of susceptible, infectious and recovered agents. The function get_agents_avg_props averages over all agents the values returned by functions sent to it as arguments. ","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"df = get_agents_avg_props(model, \n    ag -> ag.atype == susceptible ? 1 : 0,\n    ag -> ag.atype == infectious ? 1 : 0, \n    ag -> ag.atype == recovered ? 1 : 0, \n    labels = [\"Susceptible\", \"Infected\", \"Recovered\"],\n    plot_result = true\n)","category":"page"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"(Image: png)","category":"page"},{"location":"SIR/#References","page":"SIR model","title":"References","text":"","category":"section"},{"location":"SIR/","page":"SIR model","title":"SIR model","text":"1.) https://towardsdatascience.com/modelling-a-pandemic-eb94025f248f","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"EasyABM provides following functions for agent based simulations. ","category":"page"},{"location":"api/#Functions-for-creating-agents","page":"API","title":"Functions for creating agents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"con_2d_agent\ncon_2d_agents\ngrid_2d_agent\ngrid_2d_agents\ncon_3d_agent\ncon_3d_agents\ngrid_3d_agent\ngrid_3d_agents\ngraph_agent\ngraph_agents\ncreate_similar","category":"page"},{"location":"api/#EasyABM.con_2d_agent","page":"API","title":"EasyABM.con_2d_agent","text":"con_2d_agent(; pos, space_type, agent_type, kwargs...) -> EasyABM.Agent2D{Float64, EasyABM.PeriodicType, EasyABM.StaticType}\n\n\nCreates a single 2d agent with properties specified as keyword arguments.  Following property names are reserved for some specific agent properties      - pos : position     - vel : velocity     - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keeps_record_of : Set of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.con_2d_agents","page":"API","title":"EasyABM.con_2d_agents","text":"con_2d_agents(n::Int64; pos, space_type, agent_type, kwargs...) -> Vector{EasyABM.Agent2D{Float64, EasyABM.PeriodicType, EasyABM.StaticType}}\n\n\nCreates a list of n 2d agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.grid_2d_agent","page":"API","title":"EasyABM.grid_2d_agent","text":"grid_2d_agent(; pos, space_type, agent_type, kwargs...) -> EasyABM.Agent2D{Int64, EasyABM.PeriodicType, EasyABM.StaticType}\n\n\nCreates a single 2d agent with properties specified as keyword arguments.  Following property names are reserved for some specific agent properties      - pos : position     - vel : velocity     - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keeps_record_of : Set of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.grid_2d_agents","page":"API","title":"EasyABM.grid_2d_agents","text":"grid_2d_agents(n::Int64; pos, space_type, agent_type, kwargs...) -> Vector{EasyABM.Agent2D{Int64, EasyABM.PeriodicType, EasyABM.StaticType}}\n\n\nCreates a list of n 2d agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.con_3d_agent","page":"API","title":"EasyABM.con_3d_agent","text":"con_3d_agent(; pos, space_type, agent_type, kwargs...) -> EasyABM.Agent3D{Float64, EasyABM.PeriodicType, EasyABM.StaticType}\n\n\nCreates a single 3d agent with properties specified as keyword arguments. Following property names are reserved for some specific agent properties      - pos : position     - vel : velocity     - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keeps_record_of : Set of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.con_3d_agents","page":"API","title":"EasyABM.con_3d_agents","text":"con_3d_agents(n::Int64; pos, space_type, agent_type, kwargs...) -> Vector{EasyABM.Agent3D{Float64, EasyABM.PeriodicType, EasyABM.StaticType}}\n\n\nCreates a list of n 3d agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.grid_3d_agent","page":"API","title":"EasyABM.grid_3d_agent","text":"grid_3d_agent(; pos, space_type, agent_type, kwargs...) -> EasyABM.Agent3D{Int64, EasyABM.PeriodicType, EasyABM.StaticType}\n\n\nCreates a single 3d agent with properties specified as keyword arguments.  Following property names are reserved for some specific agent properties      - pos : position     - vel : velocity     - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keeps_record_of : Set of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.grid_3d_agents","page":"API","title":"EasyABM.grid_3d_agents","text":"grid_3d_agents(n::Int64; pos, space_type, agent_type, kwargs...) -> Vector{EasyABM.Agent3D{Int64, EasyABM.PeriodicType, EasyABM.StaticType}}\n\n\nCreates a list of n 2d agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.graph_agent","page":"API","title":"EasyABM.graph_agent","text":"graph_agent(; node, graph_mort_type, agent_type, kwargs...) -> EasyABM.GraphAgent{EasyABM.StaticType, EasyABM.StaticType}\n\n\nCreates a single graph agent with properties specified as keyword arguments. Following property names are reserved for some specific agent properties      - node : node where the agent is located on the graph.      - shape : shape of agent     - color : color of agent     - size : size of agent     - orientation : orientation of agent     - keeps_record_of : Set of properties that the agent records during time evolution. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.graph_agents","page":"API","title":"EasyABM.graph_agents","text":"graph_agents(n::Int64; node, graph_mort_type, agent_type, kwargs...) -> Vector{EasyABM.GraphAgent{EasyABM.StaticType, EasyABM.StaticType}}\n\n\nCreates a list of n graph agents with properties specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_similar","page":"API","title":"EasyABM.create_similar","text":"create_similar(agent::EasyABM.Agent2D{S<:Union{Float64, Int64}, P<:EasyABM.SType, T<:EasyABM.MType}, n::Int64) -> Vector\n\n\nReturns a list of n 2d agents all having same (other than _extras) properties as agent if agent is alive.  \n\n\n\n\n\ncreate_similar(agent::EasyABM.Agent2D{S<:Union{Float64, Int64}, P<:EasyABM.SType, T<:EasyABM.MType}) -> EasyABM.Agent2D\n\n\nReturns an agent with same (other than _extras) properties as given agent. \n\n\n\n\n\ncreate_similar(agent::EasyABM.GraphAgent{S<:EasyABM.MType, T<:EasyABM.MType}, n::Int64) -> Vector\n\n\nReturns a list of n 2d agents all having same (other than _extras) properties as agent.  \n\n\n\n\n\ncreate_similar(agent::EasyABM.GraphAgent{S<:EasyABM.MType, T<:EasyABM.MType}) -> EasyABM.GraphAgent\n\n\nReturns a list of n 2d agents all having same (other than _extras) properties as agent.  \n\n\n\n\n\ncreate_similar(agent::EasyABM.Agent3D{S<:Union{Float64, Int64}, P<:EasyABM.SType, T<:EasyABM.MType}, n::Int64) -> Vector\n\n\nReturns a list of n 2d agents all having same properties as agent.  \n\n\n\n\n\ncreate_similar(agent::EasyABM.Agent3D{S<:Union{Float64, Int64}, P<:EasyABM.SType, T<:EasyABM.MType}) -> EasyABM.Agent3D\n\n\nReturns an agent with same properties as given agent. \n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-defining-model","page":"API","title":"Functions for defining model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"create_2d_model\ncreate_3d_model\ncreate_graph_model","category":"page"},{"location":"api/#EasyABM.create_2d_model","page":"API","title":"EasyABM.create_2d_model","text":"create_2d_model(; graphics, size, random_positions, space_type, kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_3d_model","page":"API","title":"EasyABM.create_3d_model","text":"create_3d_model(agents::Array{EasyABM.Agent3D{S<:Union{Float64, Int64}, A<:EasyABM.SType, B<:EasyABM.MType}, 1}; graphics, agents_type, size, random_positions, space_type, kwargs...) -> EasyABM.SpaceModel3D{EasyABM.StaticType, _A, EasyABM.PeriodicType} where _A<:Union{Float64, Int64}\n\n\nCreates a 3d model with \n\nagents : list of agents.\ngraphics : if true, properties of shape, color, orientation will be assigned to each agent by default, if not already assigned by the user.\nagents_type : Set it to Static if number of agents is fixed during model run. Otherwise set it to Mortal. \nsize : A tuple (dimx, dimy, dimz) which tells the number of blocks the space is to be divided into along x, y and z directions. An agent can take\n\npositions from 0 to dimx in x-direction, 0 to dimy in y direction and 0 to dimz in z direction. The agents can move continuously or  in discrete steps depending upon how user implements the step rule (unless the agents are of grid type which can only move in dicrete steps).  Each unit block of space is called a patch which like agents can be assigned  its own properties.  \n\nrandom_positions : If this property is true, each agent, will be assigned a random position. \nspace_type : Set it to Periodic or NPeriodic depending upon if the space is periodic or not. \nkwargs` : Keyword argments used as model parameters. \n\n\n\n\n\ncreate_3d_model(; graphics, size, random_positions, space_type, kwargs...) -> EasyABM.SpaceModel3D{EasyABM.StaticType, Int64, EasyABM.PeriodicType}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_graph_model","page":"API","title":"EasyABM.create_graph_model","text":"create_graph_model(agents::Array{EasyABM.GraphAgent{A<:EasyABM.MType, B<:EasyABM.MType}, 1}, graph::EasyABM.AbstractPropGraph{S<:EasyABM.MType, G<:EasyABM.GType}; agents_type, graphics, random_positions, kwargs...) -> EasyABM.GraphModel{_A, EasyABM.StaticType} where _A<:EasyABM.MType\n\n\nCreates a model with \n\nagents : list of agents.\ngraph  : A graph created with Graphs.jl and converted to EasyABM graph type Or created directly using EasyABM graph functionality.\ngraphics : if true properties of pos, shape, color, orientation will be assigned to each agent by default, if not already assigned by user.\nagents_type : Set it to Static if number of agents is fixed during model run. Otherwise set it to Mortal. \nrandom_positions : If this property is true, each agent will be assigned a random node on the graph. \nkwargs : Keyword argments used as model parameters. \n\n\n\n\n\ncreate_graph_model(graph::EasyABM.AbstractPropGraph{S<:EasyABM.MType, G<:EasyABM.GType}; graphics, random_positions, kwargs...) -> EasyABM.GraphModel{_A, EasyABM.StaticType} where _A<:EasyABM.MType\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-initialising,-running-and-visualising","page":"API","title":"Functions for initialising, running and visualising","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"init_model!\nrun_model!\nrun_model_epochs!\ndraw_frame\nanimate_sim\ncreate_interactive_app","category":"page"},{"location":"api/#EasyABM.init_model!","page":"API","title":"EasyABM.init_model!","text":"init_model!(model::EasyABM.SpaceModel2D; initialiser, props_to_record)\n\n\nInitiates the simulation with a user defined initialiser function which takes the model as its only argument.  Model parameters along with agent properties can be set (or modified) from within a user defined function and then sending it as initialiser argument in init_model!. The properties of  agents, patches and model that are to be recorded during time evolution can be specified through the dictionary argument props_to_record.  List of agent properties to be recorded are specified with key \"agents\" and value the list of property names as symbols. If a nonempty list of  agents properties is specified, it will replace the keeps_record_of list of each agent. Properties of patches and model are similarly specified with keys \"patches\" and \"model\" respectively.\n\n\n\n\n\ninit_model!(model::EasyABM.SpaceModel3D; initialiser, props_to_record)\n\n\nInitiates the simulation with a user defined initialiser function which takes the model as its only argument.  Model parameters along with agent properties can be set (or modified) from within a user defined function and then sending it as initialiser  argument in init_model!. The properties of agents, patches and model that are to be recorded during time evolution can be specified through  the dictionary argument props_to_record. List of agent properties to be recorded are specified with key \"agents\" and value the list of property  names as symbols. If a nonempty list of agents properties is specified, it will replace the keeps_record_of list of each agent. Properties of  patches and model are similarly specified with keys \"patches\" and \"model\" respectively.\n\n\n\n\n\ninit_model!(model::EasyABM.GraphModel; initialiser, props_to_record)\n\n\nInitiates the simulation with a user defined initialiser function which takes the model as its only argument.  Model parameters along with agent and graph properties can be set (or modified) from within a user defined function and then sending  it as initialiser argument in init_model!. The properties of  agents, nodes, edges and the model that are to be recorded during time evolution can be specified through the dictionary argument props_to_record.  List of agent properties to be recorded are specified with key \"agents\" and value the list of property names as symbols. If a nonempty list of  agents properties is specified, it will replace the keeps_record_of list of each agent. Properties of nodes, edges and model are similarly specified with keys \"nodes\", \"edges\" and \"model\" respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.run_model!","page":"API","title":"EasyABM.run_model!","text":"run_model!(model::EasyABM.SpaceModel2D; steps, step_rule)\n\n\nRuns the simulation for steps number of steps.\n\n\n\n\n\nrun_model!(model::EasyABM.SpaceModel3D; steps, step_rule)\n\n\nRuns the simulation for steps number of steps.\n\n\n\n\n\nrun_model!(model::EasyABM.GraphModel; steps, step_rule)\n\n\nRuns the simulation for steps number of steps.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.run_model_epochs!","page":"API","title":"EasyABM.run_model_epochs!","text":"run_model_epochs!(model::EasyABM.SpaceModel2D; steps_per_epoch, num_epochs, step_rule, save_to_folder)\n\n\nRuns the simulation for num_epochs number of epochs where each epoch consists of steps_per_epoch number of steps. The model is saved as .jld2 file and the model.tick is reset to 1 at the end of each epoch.\n\n\n\n\n\nrun_model_epochs!(model::EasyABM.SpaceModel3D; steps_per_epoch, num_epochs, step_rule, save_to_folder)\n\n\nRuns the simulation for num_epochs number of epochs where each epoch consists of steps_per_epoch number of steps. The model is saved as .jld2 file and the model.tick is reset to 1 at the end of each epoch.\n\n\n\n\n\nrun_model_epochs!(model::EasyABM.GraphModel; steps_per_epoch, num_epochs, step_rule, save_to_folder)\n\n\nRuns the simulation for num_epochs number of epochs where each epoch consists of steps_per_epoch number of steps. The model is saved as .jld2 file and the model.tick is reset to 1 at the end of each epoch.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.draw_frame","page":"API","title":"EasyABM.draw_frame","text":"draw_frame(model::EasyABM.SpaceModel2D; frame, show_patches) -> Luxor.Drawing\n\n\nDraws a specific frame.\n\n\n\n\n\ndraw_frame(model::EasyABM.SpaceModel3D; frame, show_patches, vis) -> MeshCat.DisplayedVisualizer\n\n\nDraws a specific frame.\n\n\n\n\n\ndraw_frame(model::EasyABM.GraphModel; frame, show_graph, mark_nodes) -> Luxor.Drawing\n\n\nDraws a specific frame.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.animate_sim","page":"API","title":"EasyABM.animate_sim","text":"animate_sim(model::EasyABM.SpaceModel2D) -> Widgets.Widget{:default, Any}\nanimate_sim(model::EasyABM.SpaceModel2D, frames::Int64; agent_plots, patch_plots, model_plots, plots_only, path, show_patches, tail) -> Widgets.Widget{:default, Any}\n\n\nCreates an animation from the data collected during model run.\n\n\n\n\n\nanimate_sim(model::EasyABM.SpaceModel3D) -> Union{Nothing, MeshCat.DisplayedVisualizer}\nanimate_sim(model::EasyABM.SpaceModel3D, frames::Int64; show_patches, tail) -> Union{Nothing, MeshCat.DisplayedVisualizer}\n\n\nCreates a 3d animation from the data collected during the model run.\n\n\n\n\n\nanimate_sim(model::EasyABM.GraphModel) -> Widgets.Widget{:default, Any}\nanimate_sim(model::EasyABM.GraphModel, frames::Int64; agent_plots, node_plots, model_plots, plots_only, path, show_graph, mark_nodes, tail, agent_path) -> Widgets.Widget{:default, Any}\n\n\nCreates an animation from the data collected during model run.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_interactive_app","page":"API","title":"EasyABM.create_interactive_app","text":"create_interactive_app(model::EasyABM.SpaceModel2D; initialiser, props_to_record, step_rule, agent_controls, model_controls, agent_plots, patch_plots, model_plots, plots_only, path, frames, show_patches, tail) -> Widgets.Widget{:default, Any}\n\n\nCreates an interactive app for the model.\n\n\n\n\n\ncreate_interactive_app(model::EasyABM.SpaceModel3D; initialiser, props_to_record, step_rule, agent_controls, model_controls, agent_plots, patch_plots, model_plots, plots_only, frames, show_patches, tail) -> Widgets.Widget{:default, Any}\n\n\nCreates an interactive app for the model.\n\n\n\n\n\ncreate_interactive_app(model::EasyABM.GraphModel; initialiser, props_to_record, step_rule, agent_controls, model_controls, agent_plots, node_plots, model_plots, plots_only, path, frames, show_graph, mark_nodes, tail, agent_path) -> Widgets.Widget{:default, Any}\n\n\nCreates an interactive app for the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-accessing,-saving-and-retrieving-data.","page":"API","title":"Functions for accessing, saving and retrieving data.","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_agent_data \nget_patch_data \nget_node_data\nget_edge_data \nget_model_data \nlatest_propvals\npropnames\nget_nums_agents \nget_nums_patches\nget_nums_nodes \nget_nums_edges\nget_agents_avg_props\nget_patches_avg_props\nget_nodes_avg_props\nget_edges_avg_props\nsave_model\nopen_model","category":"page"},{"location":"api/#EasyABM.get_agent_data","page":"API","title":"EasyABM.get_agent_data","text":"get_agent_data(agent::EasyABM.AbstractAgent, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, EasyABM.MortalType}, EasyABM.AbstractSpaceModel{EasyABM.MortalType}}) -> NamedTuple{(:birthtime, :deathtime, :record), Tuple{Int64, Int64, DataFrames.DataFrame}}\nget_agent_data(agent::EasyABM.AbstractAgent, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, EasyABM.MortalType}, EasyABM.AbstractSpaceModel{EasyABM.MortalType}}, props) -> NamedTuple{(:birthtime, :deathtime, :record), Tuple{Int64, Int64, DataFrames.DataFrame}}\n\n\n\n\n\n\nget_agent_data(agent::EasyABM.AbstractAgent, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, EasyABM.StaticType}, EasyABM.AbstractSpaceModel{EasyABM.StaticType}}) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\nget_agent_data(agent::EasyABM.AbstractAgent, model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, EasyABM.StaticType}, EasyABM.AbstractSpaceModel{EasyABM.StaticType}}, props) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_patch_data","page":"API","title":"EasyABM.get_patch_data","text":"get_patch_data(patch, model::EasyABM.AbstractSpaceModel) -> Union{Nothing, NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}}\nget_patch_data(patch, model::EasyABM.AbstractSpaceModel, props) -> Union{Nothing, NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_node_data","page":"API","title":"EasyABM.get_node_data","text":"get_node_data(node::Int64, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}) -> NamedTuple{(:birthtime, :deathtime, :record), Tuple{Int64, Int64, DataFrames.DataFrame}}\nget_node_data(node::Int64, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}, props) -> NamedTuple{(:birthtime, :deathtime, :record), Tuple{Int64, Int64, DataFrames.DataFrame}}\n\n\n\n\n\n\nget_node_data(node::Int64, model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\nget_node_data(node::Int64, model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}, props) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_edge_data","page":"API","title":"EasyABM.get_edge_data","text":"get_edge_data(i::Int64, j::Int64, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}) -> NamedTuple{(:birth_death_times, :record), Tuple{Vector{Tuple{Int64, Int64}}, DataFrames.DataFrame}}\nget_edge_data(i::Int64, j::Int64, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}, props) -> NamedTuple{(:birth_death_times, :record), Tuple{Vector{Tuple{Int64, Int64}}, DataFrames.DataFrame}}\n\n\n\n\n\n\nget_edge_data(edge, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}) -> NamedTuple{(:birth_death_times, :record), Tuple{Vector{Tuple{Int64, Int64}}, DataFrames.DataFrame}}\nget_edge_data(edge, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}, props) -> NamedTuple{(:birth_death_times, :record), Tuple{Vector{Tuple{Int64, Int64}}, DataFrames.DataFrame}}\n\n\n\n\n\n\nget_edge_data(i::Int64, j::Int64, model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}})\nget_edge_data(i::Int64, j::Int64, model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}, props)\n\n\n\n\n\n\nget_edge_data(edge, model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}})\nget_edge_data(edge, model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}, props)\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_model_data","page":"API","title":"EasyABM.get_model_data","text":"get_model_data(model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractSpaceModel}) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\nget_model_data(model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractSpaceModel}, props) -> NamedTuple{(:record,), Tuple{DataFrames.DataFrame}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.latest_propvals","page":"API","title":"EasyABM.latest_propvals","text":"latest_propvals(obj::EasyABM.AbstractPropDict, propname::Symbol, n::Int64) -> Any\n\n\nlast recorded (not current) property values.\n\n\n\n\n\nlatest_propvals(agent::EasyABM.AbstractPropDict, model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractSpaceModel}, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(patch, model::EasyABM.AbstractSpaceModel, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(node::Int64, model::EasyABM.GraphModel, propname::Symbol, n::Int64) -> Any\n\n\nLast recorded property values. \n\n\n\n\n\nlatest_propvals(i::Int64, j::Int64, model::EasyABM.GraphModel, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\nlatest_propvals(edge, model::EasyABM.GraphModel, propname::Symbol, n::Int64) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.propnames","page":"API","title":"EasyABM.propnames","text":"propnames(obj::Union{EasyABM.AbstractAgent2D, EasyABM.AbstractAgent3D}) -> Vector{Symbol}\n\n\n\n\n\n\npropnames(obj::EasyABM.GraphAgent) -> Vector{Symbol}\n\n\n\n\n\n\npropnames(obj::EasyABM.AbstractPropDict) -> Vector{Symbol}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nums_agents","page":"API","title":"EasyABM.get_nums_agents","text":"\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nums_patches","page":"API","title":"EasyABM.get_nums_patches","text":"get_nums_patches(model::EasyABM.AbstractSpaceModel, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nums_nodes","page":"API","title":"EasyABM.get_nums_nodes","text":"get_nums_nodes(model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_nums_nodes(model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nums_edges","page":"API","title":"EasyABM.get_nums_edges","text":"get_nums_edges(model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_nums_edges(model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}, conditions::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_agents_avg_props","page":"API","title":"EasyABM.get_agents_avg_props","text":"get_agents_avg_props(model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, EasyABM.MortalType}, EasyABM.AbstractSpaceModel{EasyABM.MortalType}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_agents_avg_props(model::Union{EasyABM.AbstractGraphModel{T<:EasyABM.MType, EasyABM.StaticType}, EasyABM.AbstractSpaceModel{EasyABM.StaticType}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_patches_avg_props","page":"API","title":"EasyABM.get_patches_avg_props","text":"get_patches_avg_props(model::EasyABM.AbstractSpaceModel, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nodes_avg_props","page":"API","title":"EasyABM.get_nodes_avg_props","text":"get_nodes_avg_props(model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_nodes_avg_props(model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_edges_avg_props","page":"API","title":"EasyABM.get_edges_avg_props","text":"get_edges_avg_props(model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\nget_edges_avg_props(model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}, props::Function...; labels, plot_result) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.save_model","page":"API","title":"EasyABM.save_model","text":"save_model(model; model_name, save_as, folder)\n\n\nSaves the model on disk as jld2 file. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.open_model","page":"API","title":"EasyABM.open_model","text":"open_model(; model_name, path) -> Any\n\n\nGets the model that was saved before as jld2. \n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-creating-and-modifying-a-graph","page":"API","title":"Functions for creating and modifying a graph","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"static_simple_graph\nstatic_dir_graph\ndynamic_simple_graph\ndynamic_dir_graph\nconvert_type\nhex_grid_graph\nsquare_grid_graph\ntriangular_grid_graph\ndouble_triangular_grid_graph\ndraw_graph\nadd_node!\nadd_nodes!\nkill_node!\ncreate_edge! \nkill_edge!\nkill_all_edges!\nflush_graph!\nis_digraph\nis_static","category":"page"},{"location":"api/#EasyABM.static_simple_graph","page":"API","title":"EasyABM.static_simple_graph","text":"static_simple_graph(n::Int64) -> EasyABM.SimplePropGraph{EasyABM.StaticType, EasyABM.SimGType}\n\n\nCreates a simple prop graph with n vertices. \n\n\n\n\n\nstatic_simple_graph(structure::Dict{Int64, Vector{Int64}}) -> Union{Nothing, EasyABM.SimplePropGraph{EasyABM.StaticType, EasyABM.SimGType}}\n\n\nCreates a simple prop graph with given structure. \n\n\n\n\n\nstatic_simple_graph(A::Matrix{Int64}) -> Union{Nothing, EasyABM.SimplePropGraph{EasyABM.StaticType, EasyABM.SimGType}}\n\n\nCreates a simple prop graph for given Adjacency matrix. \n\n\n\n\n\nstatic_simple_graph(A::SparseArrays.SparseMatrixCSC{Int64, Int64}) -> Union{Nothing, EasyABM.SimplePropGraph{EasyABM.StaticType, EasyABM.SimGType}}\n\n\nCreates a simple prop graph for adjacency_matrix given as a Sparse Matrix. \n\n\n\n\n\nstatic_simple_graph(g::Graphs.SimpleGraphs.SimpleGraph{Int64}) -> Union{Nothing, EasyABM.SimplePropGraph{EasyABM.StaticType, EasyABM.SimGType}}\n\n\nCreates a simple prop graph from a given simple graph created with Graphs.jl. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.static_dir_graph","page":"API","title":"EasyABM.static_dir_graph","text":"static_dir_graph(n::Int64) -> EasyABM.DirPropGraph{EasyABM.StaticType, EasyABM.DirGType}\n\n\nCreates a directed prop graph with n vertices. \n\n\n\n\n\nstatic_dir_graph(in_structure::Dict{Int64, Vector{Int64}}) -> Union{Nothing, EasyABM.DirPropGraph{EasyABM.StaticType, EasyABM.DirGType}}\n\n\nCreates a directed prop graph with given structure. \n\n\n\n\n\nstatic_dir_graph(A::Matrix{Int64}) -> Union{Nothing, EasyABM.DirPropGraph{EasyABM.StaticType, EasyABM.DirGType}}\n\n\nCreates a directed prop graph for given Adjacency matrix. \n\n\n\n\n\nstatic_dir_graph(A::SparseArrays.SparseMatrixCSC{Int64, Int64}) -> Union{Nothing, EasyABM.DirPropGraph{EasyABM.StaticType, EasyABM.DirGType}}\n\n\nCreates a directed prop graph for adjacency matrix given as a Sparse Matrix. \n\n\n\n\n\nstatic_dir_graph(g::Graphs.SimpleGraphs.SimpleDiGraph{Int64}) -> Union{Nothing, EasyABM.DirPropGraph{EasyABM.StaticType, EasyABM.DirGType}}\n\n\nCreates a directed prop graph for a given directed graph created with Graphs.jl. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.dynamic_simple_graph","page":"API","title":"EasyABM.dynamic_simple_graph","text":"dynamic_simple_graph(n::Int64) -> EasyABM.SimplePropGraph{EasyABM.MortalType, EasyABM.SimGType}\n\n\nCreates a simple prop graph with n vertices. \n\n\n\n\n\ndynamic_simple_graph(structure::Dict{Int64, Vector{Int64}}) -> Union{Nothing, EasyABM.SimplePropGraph{EasyABM.MortalType, EasyABM.SimGType}}\n\n\nCreates a simple prop graph with given structure. \n\n\n\n\n\ndynamic_simple_graph(A::Matrix{Int64}) -> Union{Nothing, EasyABM.SimplePropGraph{EasyABM.MortalType, EasyABM.SimGType}}\n\n\nCreates a simple prop graph for given Adjacency matrix. \n\n\n\n\n\ndynamic_simple_graph(A::SparseArrays.SparseMatrixCSC{Int64, Int64}) -> Union{Nothing, EasyABM.SimplePropGraph{EasyABM.MortalType, EasyABM.SimGType}}\n\n\nCreates a simple prop graph for adjacency_matrix given as a Sparse Matrix. \n\n\n\n\n\ndynamic_simple_graph(g::Graphs.SimpleGraphs.SimpleGraph{Int64}) -> Union{Nothing, EasyABM.SimplePropGraph{EasyABM.MortalType, EasyABM.SimGType}}\n\n\nCreates a simple prop graph from a given simple graph created with Graphs.jl. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.dynamic_dir_graph","page":"API","title":"EasyABM.dynamic_dir_graph","text":"dynamic_dir_graph(n::Int64) -> EasyABM.DirPropGraph{EasyABM.MortalType, EasyABM.DirGType}\n\n\nCreates a directed prop graph with n vertices. \n\n\n\n\n\ndynamic_dir_graph(in_structure::Dict{Int64, Vector{Int64}}) -> Union{Nothing, EasyABM.DirPropGraph{EasyABM.MortalType, EasyABM.DirGType}}\n\n\nCreates a directed prop graph with given structure. \n\n\n\n\n\ndynamic_dir_graph(A::Matrix{Int64}) -> Union{Nothing, EasyABM.DirPropGraph{EasyABM.MortalType, EasyABM.DirGType}}\n\n\nCreates a directed prop graph for given Adjacency matrix. \n\n\n\n\n\ndynamic_dir_graph(A::SparseArrays.SparseMatrixCSC{Int64, Int64}) -> Union{Nothing, EasyABM.DirPropGraph{EasyABM.MortalType, EasyABM.DirGType}}\n\n\nCreates a directed prop graph for adjacency matrix given as a Sparse Matrix. \n\n\n\n\n\ndynamic_dir_graph(g::Graphs.SimpleGraphs.SimpleDiGraph{Int64}) -> Union{Nothing, EasyABM.DirPropGraph{EasyABM.MortalType, EasyABM.DirGType}}\n\n\nCreates a directed prop graph for a given directed graph created with Graphs.jl. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.convert_type","page":"API","title":"EasyABM.convert_type","text":"convert_type(graph::EasyABM.SimplePropGraph, w::EasyABM.MType) -> EasyABM.SimplePropGraph{_A, EasyABM.SimGType} where _A\n\n\n\n\n\n\nconvert_type(graph::EasyABM.DirPropGraph, w::EasyABM.MType) -> EasyABM.DirPropGraph{_A, EasyABM.DirGType} where _A\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.hex_grid_graph","page":"API","title":"EasyABM.hex_grid_graph","text":"hex_grid_graph(n, k; dynamic) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.square_grid_graph","page":"API","title":"EasyABM.square_grid_graph","text":"square_grid_graph(n, k; periodic, dynamic) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.triangular_grid_graph","page":"API","title":"EasyABM.triangular_grid_graph","text":"triangular_grid_graph(n, k; dynamic) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.double_triangular_grid_graph","page":"API","title":"EasyABM.double_triangular_grid_graph","text":"double_triangular_grid_graph(n, k; dynamic) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.draw_graph","page":"API","title":"EasyABM.draw_graph","text":"draw_graph(graph; mark_nodes) -> Union{Nothing, Luxor.Drawing}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.add_node!","page":"API","title":"EasyABM.add_node!","text":"add_node!(model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}; kwargs...) -> Int64\n\n\nAdds a node with properties specified in kwargs to the model's graph.\n\n\n\n\n\nadd_node!(model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}; kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.add_nodes!","page":"API","title":"EasyABM.add_nodes!","text":"add_nodes!(n, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}; kwargs...)\n\n\nAdds n nodes with properties specified in kwargs to the model's graph.\n\n\n\n\n\nadd_nodes!(n, model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}; kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.kill_node!","page":"API","title":"EasyABM.kill_node!","text":"kill_node!(node, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}) -> Union{Nothing, Int64}\n\n\nRemoves a node from model graph. For performance reasons the function does not check if the node contains the node so it will throw an error if the user tries to delete a node which is not there. Also the node will not be deleted if the agents in the model can not be killed and the number of agents at the given node is nonzero.\n\n\n\n\n\nkill_node!(node, model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}})\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.create_edge!","page":"API","title":"EasyABM.create_edge!","text":"create_edge!(i, j, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}; kwargs...)\n\n\nAdds an edge with properties kwargs to model graph. \n\n\n\n\n\ncreate_edge!(edge, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}; kwargs...)\n\n\nAdds an edge with properties kwargs to model graph. \n\n\n\n\n\ncreate_edge!(i, j, model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}; kwargs...)\n\n\n\n\n\n\ncreate_edge!(edge, model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}; kwargs...)\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.kill_edge!","page":"API","title":"EasyABM.kill_edge!","text":"kill_edge!(i, j, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}) -> Union{Nothing, EasyABM.PropDataDict{Symbol, Any}}\n\n\nRemoves edge from the model graph. \n\n\n\n\n\nkill_edge!(edge, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}) -> Union{Nothing, EasyABM.PropDataDict{Symbol, Any}}\n\n\nRemoves edge from the model graph.\n\n\n\n\n\nkill_edge!(i, j, model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}})\n\n\n\n\n\n\nkill_edge!(edge, model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}})\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.kill_all_edges!","page":"API","title":"EasyABM.kill_all_edges!","text":"kill_all_edges!(model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}})\n\n\nRemoves all edges from the model graph.\n\n\n\n\n\nkill_all_edges!(model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}})\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.flush_graph!","page":"API","title":"EasyABM.flush_graph!","text":"flush_graph!(model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}}) -> Int64\n\n\nRemoves the graph and all of related data completely. \n\n\n\n\n\nflush_graph!(model::Union{EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}})\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.is_digraph","page":"API","title":"EasyABM.is_digraph","text":"is_digraph(g::EasyABM.SimplePropGraph) -> Bool\n\n\n\n\n\n\nis_digraph(g::EasyABM.DirPropGraph) -> Bool\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.is_static","page":"API","title":"EasyABM.is_static","text":"\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Helper-functions-for-agents","page":"API","title":"Helper functions for agents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_grid_loc\nget_node_loc\nget_id\nagents_at\nnum_agents_at\nagent_with_id\nis_alive\nget_agents \nnum_agents \nkill_agent!\nadd_agent!","category":"page"},{"location":"api/#EasyABM.get_grid_loc","page":"API","title":"EasyABM.get_grid_loc","text":"get_grid_loc(agent::EasyABM.Agent2D{<:Float64}) -> Tuple{Int64, Int64}\n\n\nReturns grid location of the agent.\n\n\n\n\n\nget_grid_loc(agent::EasyABM.Agent2D{Int64}) -> Vect{2, <:Int64}\n\n\nReturns grid location of the agent.\n\n\n\n\n\nget_grid_loc(agent::EasyABM.Agent3D{<:Float64}) -> Tuple{Int64, Int64, Int64}\n\n\nReturns grid location of the agent.\n\n\n\n\n\nget_grid_loc(agent::EasyABM.Agent3D{Int64}) -> Vect{3, <:Int64}\n\n\nReturns grid location of the agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_node_loc","page":"API","title":"EasyABM.get_node_loc","text":"get_node_loc(agent::EasyABM.GraphAgent) -> Int64\n\n\nReturns node location of the agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_id","page":"API","title":"EasyABM.get_id","text":"get_id(agent::EasyABM.AbstractAgent) -> Any\n\n\nReturns agents id.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.agents_at","page":"API","title":"EasyABM.agents_at","text":"agents_at(patch, model::EasyABM.SpaceModel2D) -> Base.Generator\n\n\nReturns list of agents at a given patch.\n\n\n\n\n\nagents_at(patch, model::EasyABM.SpaceModel3D) -> Base.Generator\n\n\nReturns list of agents at a given patch.\n\n\n\n\n\nagents_at(node, model::EasyABM.GraphModel{EasyABM.MortalType, T<:EasyABM.MType}) -> Base.Generator\n\n\nReturns list of agents at a given node. \n\n\n\n\n\nagents_at(node, model::EasyABM.GraphModel{EasyABM.StaticType, T<:EasyABM.MType}) -> Base.Generator\n\n\nReturns list of agents at a given node. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_agents_at","page":"API","title":"EasyABM.num_agents_at","text":"num_agents_at(patch, model::EasyABM.AbstractSpaceModel) -> Int64\n\n\nReturns number of agents at a given patch.\n\n\n\n\n\nnum_agents_at(node, model::EasyABM.AbstractGraphModel) -> Int64\n\n\nReturns number of agents at a given node. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.agent_with_id","page":"API","title":"EasyABM.agent_with_id","text":"agent_with_id(i::Int64, model::EasyABM.SpaceModel2D{EasyABM.MortalType, S<:Union{Float64, Int64}, P<:EasyABM.SType}) -> Union{Nothing, EasyABM.Agent2D{S, P, EasyABM.MortalType} where {S<:Union{Float64, Int64}, P<:EasyABM.SType}}\n\n\nReturns agent having given id.\n\n\n\n\n\nagent_with_id(i::Int64, model::EasyABM.SpaceModel2D{EasyABM.StaticType}) -> Union{Nothing, EasyABM.Agent2D{S, P, EasyABM.StaticType} where {S<:Union{Float64, Int64}, P<:EasyABM.SType}}\n\n\nReturns agent having given id.\n\n\n\n\n\nagent_with_id(i::Int64, model::EasyABM.SpaceModel3D{EasyABM.MortalType, S<:Union{Float64, Int64}, P<:EasyABM.SType}) -> Union{Nothing, EasyABM.Agent3D{S, P, EasyABM.MortalType} where {S<:Union{Float64, Int64}, P<:EasyABM.SType}}\n\n\nReturns agent having given id.\n\n\n\n\n\nagent_with_id(i::Int64, model::EasyABM.SpaceModel3D{EasyABM.StaticType}) -> Union{Nothing, EasyABM.Agent3D{S, P, EasyABM.StaticType} where {S<:Union{Float64, Int64}, P<:EasyABM.SType}}\n\n\nReturns agent having given id.\n\n\n\n\n\nagent_with_id(i::Int64, model::EasyABM.GraphModel{T<:EasyABM.MType, EasyABM.MortalType}) -> Union{Nothing, EasyABM.GraphAgent{T, EasyABM.MortalType} where T<:EasyABM.MType}\n\n\nReturns agent having given id.\n\n\n\n\n\nagent_with_id(i::Int64, model::EasyABM.GraphModel{T<:EasyABM.MType, EasyABM.StaticType}) -> Union{Nothing, EasyABM.GraphAgent{T, EasyABM.StaticType} where T<:EasyABM.MType}\n\n\nReturns agent having given id.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.is_alive","page":"API","title":"EasyABM.is_alive","text":"is_alive(agent::EasyABM.AbstractPropDict) -> Bool\n\n\nReturns true if agent is alive else returns false.\n\n\n\n\n\nis_alive(node, model::EasyABM.AbstractGraphModel) -> Bool\n\n\nReturns true if a node is alive else returns false.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_agents","page":"API","title":"EasyABM.get_agents","text":"get_agents(model::EasyABM.SpaceModel2D{EasyABM.MortalType, S<:Union{Float64, Int64}, P<:EasyABM.SType}, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel2D{EasyABM.MortalType, S<:Union{Float64, Int64}, P<:EasyABM.SType}) -> Base.Iterators.Filter{EasyABM.var\"#169#171\"}\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel2D{EasyABM.StaticType}, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel2D{EasyABM.StaticType}) -> Base.Generator{_A, typeof(identity)} where _A\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel3D{EasyABM.MortalType, S<:(Union{Int64, var\"#s203\"} where var\"#s203\"<:Float64), P<:EasyABM.SType}, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel3D{EasyABM.MortalType, S<:(Union{Int64, var\"#s203\"} where var\"#s203\"<:Float64), P<:EasyABM.SType}) -> Base.Iterators.Filter{EasyABM.var\"#293#295\"}\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel3D{EasyABM.StaticType}, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_agents(model::EasyABM.SpaceModel3D{EasyABM.StaticType}) -> Base.Generator{_A, typeof(identity)} where _A\n\n\n\n\n\n\nget_agents(model::EasyABM.GraphModel{T<:EasyABM.MType, EasyABM.MortalType}, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_agents(model::EasyABM.GraphModel{T<:EasyABM.MType, EasyABM.MortalType}) -> Base.Iterators.Filter{EasyABM.var\"#464#466\"}\n\n\n\n\n\n\nget_agents(model::EasyABM.GraphModel{T<:EasyABM.MType, EasyABM.StaticType}, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_agents(model::EasyABM.GraphModel{T<:EasyABM.MType, EasyABM.StaticType}) -> Base.Generator{_A, typeof(identity)} where _A\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_agents","page":"API","title":"EasyABM.num_agents","text":"num_agents(model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractSpaceModel}, condition::Function) -> Any\n\n\n\n\n\n\nnum_agents(model::Union{EasyABM.AbstractGraphModel, EasyABM.AbstractSpaceModel}) -> Int64\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.kill_agent!","page":"API","title":"EasyABM.kill_agent!","text":"kill_agent!(agent::EasyABM.AbstractAgent, model::EasyABM.AbstractSpaceModel{EasyABM.MortalType}) -> Union{Nothing, Int64}\n\n\nSets the agent as inactive thus effectively removing from the model. However, the removed agents  are permanently removed from the list model.agents only once after the step_rule.\n\n\n\n\n\nkill_agent!(agent::EasyABM.AbstractAgent, model::EasyABM.AbstractSpaceModel{EasyABM.StaticType})\n\n\n\n\n\n\nkill_agent!(agent::EasyABM.AbstractAgent, model::EasyABM.AbstractGraphModel{T<:EasyABM.MType, EasyABM.MortalType}) -> Union{Nothing, Int64}\n\n\nSets the agent as inactive thus effectively removing from the model. However, the removed agents  are permanently removed from the list model.agents only after each step.\n\n\n\n\n\nkill_agent!(agent::EasyABM.AbstractAgent, model::EasyABM.AbstractGraphModel{T<:EasyABM.MType, EasyABM.StaticType})\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.add_agent!","page":"API","title":"EasyABM.add_agent!","text":"add_agent!(agent, model::EasyABM.AbstractSpaceModel{EasyABM.StaticType})\n\n\n\n\n\n\nadd_agent!(agent, model::EasyABM.AbstractGraphModel{T<:EasyABM.MType, EasyABM.StaticType})\n\n\n\n\n\n\nadd_agent!(agent, model::EasyABM.SpaceModel2D{EasyABM.MortalType}) -> Union{Nothing, Int64}\n\n\nAdds the agent to the model.\n\n\n\n\n\nadd_agent!(agent, model::EasyABM.SpaceModel3D{EasyABM.MortalType}) -> Union{Nothing, Int64}\n\n\nAdds the agent to the model.\n\n\n\n\n\nadd_agent!(agent, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}}) -> Union{Nothing, Int64}\n\n\nAdds the agent to the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-for-getting-neighbor-agents.","page":"API","title":"Functions for getting neighbor agents.","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"neighbor_patches_moore\nneighbor_patches_neumann\nneighbors\nin_neighbors\nout_neighbors\nneighbors_moore\nneighbors_neumann","category":"page"},{"location":"api/#EasyABM.neighbor_patches_moore","page":"API","title":"EasyABM.neighbor_patches_moore","text":"Returns patches neighboring the given agent's patch.\n\n\n\n\n\nReturns patches neighboring the given agent's patch.\n\n\n\n\n\nneighbor_patches_moore(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D) -> Vector{Tuple{Int64, Int64}}\nneighbor_patches_moore(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D, dist::Int64) -> Vector{Tuple{Int64, Int64}}\n\n\nReturns patches neighboring the given patch.\n\n\n\n\n\nneighbor_patches_moore(patch::Tuple{Int64, Int64, Int64}, model::EasyABM.SpaceModel3D{T, S, P<:EasyABM.PeriodicType}) -> Vector{Tuple{Int64, Int64, Int64}}\nneighbor_patches_moore(patch::Tuple{Int64, Int64, Int64}, model::EasyABM.SpaceModel3D{T, S, P<:EasyABM.PeriodicType}, dist::Int64) -> Vector{Tuple{Int64, Int64, Int64}}\n\n\nReturns patches neighboring given agent's patch.\n\n\n\n\n\nReturns patches neighboring given agent's patch.\n\n\n\n\n\nneighbor_patches_moore(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D) -> Vector{Tuple{Int64, Int64, Int64}}\nneighbor_patches_moore(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D, dist::Int64) -> Vector{Tuple{Int64, Int64, Int64}}\n\n\nReturns patches neighboring the given patch.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.neighbor_patches_neumann","page":"API","title":"EasyABM.neighbor_patches_neumann","text":"neighbor_patches_neumann(patch::Tuple{Int64, Int64}, model::EasyABM.SpaceModel2D{T, S, P<:EasyABM.PeriodicType}) -> Vector{Tuple{Int64, Int64}}\nneighbor_patches_neumann(patch::Tuple{Int64, Int64}, model::EasyABM.SpaceModel2D{T, S, P<:EasyABM.PeriodicType}, dist::Int64) -> Vector{Tuple{Int64, Int64}}\n\n\nReturns patches neighboring the given agent's patch.\n\n\n\n\n\nneighbor_patches_neumann(patch::Tuple{Int64, Int64}, model::EasyABM.SpaceModel2D{T, S, P<:EasyABM.NPeriodicType}) -> Vector{Tuple{Int64, Int64}}\nneighbor_patches_neumann(patch::Tuple{Int64, Int64}, model::EasyABM.SpaceModel2D{T, S, P<:EasyABM.NPeriodicType}, dist::Int64) -> Vector{Tuple{Int64, Int64}}\n\n\nReturns patches neighboring the given agent's patch.\n\n\n\n\n\nneighbor_patches_neumann(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D) -> Vector{Tuple{Int64, Int64}}\nneighbor_patches_neumann(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D, dist::Int64) -> Vector{Tuple{Int64, Int64}}\n\n\nReturns patches neighboring the given patch.\n\n\n\n\n\nneighbor_patches_neumann(patch::Tuple{Int64, Int64, Int64}, model::EasyABM.SpaceModel3D{T, S, P<:EasyABM.NPeriodicType}) -> Vector{Tuple{Int64, Int64, Int64}}\nneighbor_patches_neumann(patch::Tuple{Int64, Int64, Int64}, model::EasyABM.SpaceModel3D{T, S, P<:EasyABM.NPeriodicType}, dist::Int64) -> Vector{Tuple{Int64, Int64, Int64}}\n\n\nReturns patches neighboring given agent's patch.\n\n\n\n\n\nneighbor_patches_neumann(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D) -> Vector{Tuple{Int64, Int64, Int64}}\nneighbor_patches_neumann(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D, dist::Int64) -> Vector{Tuple{Int64, Int64, Int64}}\n\n\nReturns patches neighboring the given patch.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.neighbors","page":"API","title":"EasyABM.neighbors","text":"neighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{EasyABM.MortalType, S<:Union{Float64, Int64}, P<:EasyABM.SType}) -> Any\nneighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{EasyABM.MortalType, S<:Union{Float64, Int64}, P<:EasyABM.SType}, dist::Real) -> Any\n\n\nReturns active neighboring agents to given agent within euclidean distance dist. \n\n\n\n\n\nneighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{EasyABM.StaticType}) -> Base.Iterators.Filter\nneighbors(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{EasyABM.StaticType}, dist::Real) -> Base.Iterators.Filter\n\n\nReturns active neighboring agents to given agent within euclidean distance dist. \n\n\n\n\n\nneighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{EasyABM.MortalType, S<:Union{Float64, Int64}, P<:EasyABM.SType}) -> Any\nneighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{EasyABM.MortalType, S<:Union{Float64, Int64}, P<:EasyABM.SType}, dist::Real) -> Any\n\n\nReturns active neighboring agents to given agent within euclidean distance dist. \n\n\n\n\n\nneighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{EasyABM.StaticType}) -> Base.Iterators.Filter\nneighbors(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{EasyABM.StaticType}, dist::Real) -> Base.Iterators.Filter\n\n\nReturns active neighboring agents to given agent within euclidean distance dist. \n\n\n\n\n\nneighbors(agent::EasyABM.GraphAgent, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}}) -> Union{Base.Generator{UnitRange{Int64}, typeof(identity)}, Base.Iterators.Flatten}\n\n\nReturns agents on neighboring nodes of given agent.\n\n\n\n\n\nneighbors(agent::EasyABM.GraphAgent, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}) -> Base.Iterators.Flatten\n\n\nReturns agents on neighboring nodes of given agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.in_neighbors","page":"API","title":"EasyABM.in_neighbors","text":"in_neighbors(agent::EasyABM.GraphAgent, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}}) -> Union{Base.Generator{UnitRange{Int64}, typeof(identity)}, Base.Iterators.Flatten}\n\n\nReturns agents on neighboring incoming nodes of given agent.\n\n\n\n\n\nin_neighbors(agent::EasyABM.GraphAgent, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}) -> Base.Iterators.Flatten\n\n\nReturns agents on neighboring incoming nodes of given agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.out_neighbors","page":"API","title":"EasyABM.out_neighbors","text":"out_neighbors(agent::EasyABM.GraphAgent, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.MortalType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.MortalType}}) -> Union{Base.Generator{UnitRange{Int64}, typeof(identity)}, Base.Iterators.Flatten}\n\n\nReturns agents on neighboring outgoing nodes of given agent.\n\n\n\n\n\nout_neighbors(agent::EasyABM.GraphAgent, model::Union{EasyABM.GraphModel{EasyABM.MortalType, EasyABM.StaticType}, EasyABM.GraphModel{EasyABM.StaticType, EasyABM.StaticType}}) -> Base.Iterators.Flatten\n\n\nReturns agents on neighboring outgoing nodes of given agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.neighbors_moore","page":"API","title":"EasyABM.neighbors_moore","text":"neighbors_moore(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{EasyABM.MortalType, S<:Union{Float64, Int64}, P<:EasyABM.SType}) -> Base.Generator\nneighbors_moore(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{EasyABM.MortalType, S<:Union{Float64, Int64}, P<:EasyABM.SType}, dist::Int64) -> Base.Generator\n\n\n\n\n\n\nneighbors_moore(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{EasyABM.StaticType, S<:Union{Float64, Int64}, P<:EasyABM.SType}) -> Base.Generator{Vector{Int64}}\nneighbors_moore(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{EasyABM.StaticType, S<:Union{Float64, Int64}, P<:EasyABM.SType}, dist::Int64) -> Base.Generator{Vector{Int64}}\n\n\n\n\n\n\nneighbors_moore(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{EasyABM.MortalType, S<:Union{Float64, Int64}, P<:EasyABM.SType}) -> Base.Generator\nneighbors_moore(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{EasyABM.MortalType, S<:Union{Float64, Int64}, P<:EasyABM.SType}, dist::Int64) -> Base.Generator\n\n\n\n\n\n\nneighbors_moore(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{EasyABM.StaticType}) -> Base.Generator{Vector{Int64}}\nneighbors_moore(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{EasyABM.StaticType}, dist::Int64) -> Base.Generator{Vector{Int64}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.neighbors_neumann","page":"API","title":"EasyABM.neighbors_neumann","text":"\n\n\n\nneighbors_neumann(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{EasyABM.StaticType}) -> Base.Generator{Vector{Int64}}\nneighbors_neumann(agent::EasyABM.Agent2D, model::EasyABM.SpaceModel2D{EasyABM.StaticType}, dist::Int64) -> Base.Generator{Vector{Int64}}\n\n\n\n\n\n\n\n\n\n\nneighbors_neumann(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{EasyABM.StaticType}) -> Base.Generator{Vector{Int64}}\nneighbors_neumann(agent::EasyABM.Agent3D, model::EasyABM.SpaceModel3D{EasyABM.StaticType}, dist::Int64) -> Base.Generator{Vector{Int64}}\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Helper-functions-for-patches,-nodes,-edges","page":"API","title":"Helper functions for patches, nodes, edges","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"is_occupied\nget_nodeprop\nget_edgeprop\nset_nodeprops!\nset_edgeprops!\nget_patchprop\nset_patchprops!\nneighbor_nodes\nneighbor_patches_moore\nin_neighbor_nodes\nout_neighbor_nodes\nget_nodes\nnum_nodes\nget_edges\nnum_edges\nget_patches\nnum_patches\nrandom_empty_node\nrandom_empty_patch","category":"page"},{"location":"api/#EasyABM.is_occupied","page":"API","title":"EasyABM.is_occupied","text":"is_occupied(patch, model::EasyABM.AbstractSpaceModel) -> Any\n\n\nReturns true if a patch is occupied.\n\n\n\n\n\nis_occupied(node, model::EasyABM.AbstractGraphModel) -> Any\n\n\nReturns true if a node is occupied. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nodeprop","page":"API","title":"EasyABM.get_nodeprop","text":"get_nodeprop(key::Symbol, node::Int64, model::EasyABM.GraphModel) -> Any\n\n\nReturns the value for given property name for a node.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_edgeprop","page":"API","title":"EasyABM.get_edgeprop","text":"get_edgeprop(key::Symbol, i::Int64, j::Int64, model::EasyABM.GraphModel) -> Any\n\n\nReturns the value for given property name for an edge.\n\n\n\n\n\nget_edgeprop(key::Symbol, edge, model::EasyABM.GraphModel) -> Any\n\n\nReturns the value for given property name for an edge.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.set_nodeprops!","page":"API","title":"EasyABM.set_nodeprops!","text":"set_nodeprops!(node::Int64, model::EasyABM.GraphModel; kwargs...)\n\n\nSets properties of given node.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.set_edgeprops!","page":"API","title":"EasyABM.set_edgeprops!","text":"set_edgeprops!(i::Int64, j::Int64, model::EasyABM.GraphModel; kwargs...)\n\n\nSets properties of given edge.\n\n\n\n\n\nset_edgeprops!(edge, model::EasyABM.GraphModel; kwargs...)\n\n\nSets properties of given edge.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_patchprop","page":"API","title":"EasyABM.get_patchprop","text":"get_patchprop(key, patch, model::EasyABM.AbstractSpaceModel) -> Any\n\n\nReturns value of given property of a patch. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.set_patchprops!","page":"API","title":"EasyABM.set_patchprops!","text":"set_patchprops!(patch, model::EasyABM.AbstractSpaceModel; kwargs...)\n\n\nSets properties of the patch given as keyword arguments. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.neighbor_nodes","page":"API","title":"EasyABM.neighbor_nodes","text":"neighbor_nodes(node::Int64, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes neighboring given node.\n\n\n\n\n\nneighbor_nodes(agent::EasyABM.GraphAgent, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes neighboring node of the given agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.in_neighbor_nodes","page":"API","title":"EasyABM.in_neighbor_nodes","text":"in_neighbor_nodes(node::Int64, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes of incoming edges at given node. \n\n\n\n\n\nin_neighbor_nodes(agent::EasyABM.GraphAgent, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes of incoming edges at given agent's node.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.out_neighbor_nodes","page":"API","title":"EasyABM.out_neighbor_nodes","text":"out_neighbor_nodes(node::Int64, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes of outgoing edges at given node.\n\n\n\n\n\nout_neighbor_nodes(agent::EasyABM.GraphAgent, model::EasyABM.GraphModel) -> Vector{Int64}\n\n\nReturns nodes of outgoing edges at given agent's node.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_nodes","page":"API","title":"EasyABM.get_nodes","text":"get_nodes(model::EasyABM.GraphModel, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_nodes(model::EasyABM.GraphModel) -> Base.Generator{_A, typeof(identity)} where _A\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_nodes","page":"API","title":"EasyABM.num_nodes","text":"num_nodes(model::EasyABM.GraphModel, condition::Function) -> Int64\n\n\n\n\n\n\nnum_nodes(model::EasyABM.GraphModel) -> Int64\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_edges","page":"API","title":"EasyABM.get_edges","text":"get_edges(model::EasyABM.GraphModel, condition::Function) -> Base.Iterators.Filter\n\n\n\n\n\n\nget_edges(model::EasyABM.GraphModel) -> Base.Iterators.Flatten\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_edges","page":"API","title":"EasyABM.num_edges","text":"num_edges(model::EasyABM.GraphModel, condition::Function) -> Int64\n\n\n\n\n\n\nnum_edges(model::EasyABM.GraphModel) -> Int64\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.get_patches","page":"API","title":"EasyABM.get_patches","text":"get_patches(model::EasyABM.AbstractSpaceModel, condition::Function) -> Base.Iterators.Filter\n\n\nReturns patches satisfying the given condition.\n\n\n\n\n\nget_patches(model::EasyABM.AbstractSpaceModel) -> Base.Generator{_A, typeof(identity)} where _A\n\n\nReturns patches satisfying the given condition.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.num_patches","page":"API","title":"EasyABM.num_patches","text":"num_patches(model::EasyABM.AbstractSpaceModel, condition::Function) -> Int64\n\n\nReturns number of patches satisfying given condition.\n\n\n\n\n\nnum_patches(model::EasyABM.AbstractSpaceModel) -> Int64\n\n\nReturns number of patches satisfying given condition.\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.random_empty_node","page":"API","title":"EasyABM.random_empty_node","text":"random_empty_node(model::EasyABM.AbstractGraphModel) -> Any\n\n\nReturns an empty node chosen at random. Returns nothing if there is no empty node. \n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.random_empty_patch","page":"API","title":"EasyABM.random_empty_patch","text":"random_empty_patch(model::EasyABM.SpaceModel2D) -> Union{Nothing, Tuple{Int64, Int64}}\n\n\nReturns a random patch where no agents are present. Rerurns nothing if there is no such patch.\n\n\n\n\n\nrandom_empty_patch(model::EasyABM.SpaceModel3D) -> Union{Nothing, Tuple{Int64, Int64, Int64}}\n\n\nReturns a random patch where no agents are present. Returns nothing if there is no such patch.\n\n\n\n\n\n","category":"function"},{"location":"api/#Misc.-utility-functions","page":"API","title":"Misc. utility functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"dotprod\nveclength\ndistance\ncalculate_direction","category":"page"},{"location":"api/#EasyABM.dotprod","page":"API","title":"EasyABM.dotprod","text":"dotprod(a::Vect{N}, b::Vect{N}) -> Any\n\n\n\n\n\n\ndotprod(a::Tuple{Vararg{var\"#s22\", N}} where var\"#s22\"<:Union{Float64, Integer}, b::Tuple{Vararg{var\"#s21\", N}} where var\"#s21\"<:Union{Float64, Integer}) -> Any\n\n\n\n\n\n\ndotprod(a::Union{EasyABM.AbstractAgent2D, EasyABM.AbstractAgent3D}, b::Union{EasyABM.AbstractAgent2D, EasyABM.AbstractAgent3D}) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.veclength","page":"API","title":"EasyABM.veclength","text":"veclength(a::GeometryBasics.Vec)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.distance","page":"API","title":"EasyABM.distance","text":"distance(a::GeometryBasics.Vec, b::GeometryBasics.Vec) -> Any\n\n\n\n\n\n\ndistance(a::Tuple{Vararg{Union{Float64, Integer}, N}}, b::Tuple{Vararg{Union{Float64, Integer}, N}}) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#EasyABM.calculate_direction","page":"API","title":"EasyABM.calculate_direction","text":"calculate_direction(vel::Union{Tuple{T<:Real, T<:Real}, Vect{2, T<:Real}}) -> Any\n\n\n\n\n\n\ncalculate_direction(vel::Union{Tuple{T<:Real, T<:Real, T<:Real}, Vect{3, T<:Real}}) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"random_walkers/#Random-Walkers","page":"Random Walkers","title":"Random Walkers","text":"","category":"section"},{"location":"random_walkers/","page":"Random Walkers","title":"Random Walkers","text":"A simple example of random walkers in 2D. ","category":"page"},{"location":"random_walkers/","page":"Random Walkers","title":"Random Walkers","text":"using EasyABM","category":"page"},{"location":"random_walkers/","page":"Random Walkers","title":"Random Walkers","text":"agents = con_2d_agents(200, pos = Vect(5.0,5.0), color = cl\"red\", shape=:circle, keeps_record_of=Set([:pos]))","category":"page"},{"location":"random_walkers/","page":"Random Walkers","title":"Random Walkers","text":"model = create_2d_model(agents, agents_type = Static, space_type=NPeriodic, dt=0.2)","category":"page"},{"location":"random_walkers/","page":"Random Walkers","title":"Random Walkers","text":"function initialiser!(model)\n    colors = [cl\"red\", cl\"blue\", cl\"green\", cl\"yellow\", cl\"black\"]\n    for agent in model.agents\n        agent.color = colors[rand(1:5)]\n    end    \nend\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"random_walkers/","page":"Random Walkers","title":"Random Walkers","text":"function step_rule!(model)\n    for agent in model.agents\n        agent.pos += Vect(0.5-rand(), 0.5-rand())*model.parameters.dt\n    end\nend","category":"page"},{"location":"random_walkers/","page":"Random Walkers","title":"Random Walkers","text":"run_model!(model, steps=400, step_rule=step_rule!)","category":"page"},{"location":"random_walkers/","page":"Random Walkers","title":"Random Walkers","text":"animate_sim(model)","category":"page"},{"location":"random_walkers/","page":"Random Walkers","title":"Random Walkers","text":"(Image: png)","category":"page"},{"location":"boids/#Flocking","page":"Flocking 2D","title":"Flocking","text":"","category":"section"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"using EasyABM","category":"page"},{"location":"boids/#Step-1:-Create-Agents-and-Model","page":"Flocking 2D","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"Lets create 200 agents with properties shape, pos, vel and orientation (The orientation property is used internally by EasyABM to draw the direction agent is facing). The position pos is only accepted as a Vect which is an inbuilt vector type in EasyABM. It is also recommended for both convenience as well as performance to use Vect type for any vectorial properties in the model such as velocity and forces. The keeps_record_of argument is set of properties that the agent will record during time evolution. The model is defined with parameters:","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"min_dis : The distance between boids below which they start repelling each other.\ncoh_fac : The proportionality constant for the cohere force. \nsep_fac : The proportionality constant for the separation force.\naln_fac : The proportionality constant for the alignment force.\nvis_range : The visual range of boids.\ndt : The proportionality constant between change in position and velocity.","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"The argument agents_type is set to Static which means that the agents number will remain fixed during simulation. ","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"boids = con_2d_agents(200, shape = :arrow, pos = Vect(0.0,0.0), \n    vel=Vect(0.0,0.0), orientation = 0.0, keeps_record_of = Set([:pos, :vel, :orientation]))\nmodel = create_2d_model(boids,\n    agents_type=Static, space_type = Periodic, \n    min_dis = 0.3, coh_fac = 0.05, \n    sep_fac = 0.5, dt= 0.1, vis_range = 2.0, aln_fac = 0.35)","category":"page"},{"location":"boids/#Step-2:-Initialise-the-model","page":"Flocking 2D","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"In this step we set the positions, velocities and orientations of boids and initialise the model.","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"function initialiser!(model)\n    xdim, ydim = model.size\n    for boid in model.agents\n        boid.pos = Vect(rand()*xdim, rand()*ydim)\n        boid.orientation = rand()*2*3.14\n        boid.vel = Vect(-sin(boid.orientation), cos(boid.orientation))\n    end\nend\n\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"boids/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Flocking 2D","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"In this step we implement the step logic of the flocking model in the step_rule! function and run the model for 500 steps. ","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"\nconst ep = 0.00001\n\nfunction step_rule!(model)\n    dt = model.parameters.dt\n    for boid in model.agents\n        nbrs = neighbors(boid, model, model.parameters.vis_range)\n        coh_force = Vect(0.0,0.0) # For a Vect all coordinates must be of same type\n        sep_force = Vect(0.0,0.0) \n        aln_force = Vect(0.0,0.0)\n        num = 0\n        for nbr in nbrs\n            num+=1\n            vec = nbr.pos - boid.pos\n            coh_force += vec\n            if veclength(vec)< model.parameters.min_dis\n                sep_force -= vec\n            end\n            aln_force += nbr.vel\n        end\n        aln_force = num>0 ? (aln_force / num - boid.vel) * model.parameters.aln_fac : aln_force\n        num = max(1, num)\n        coh_force *= (model.parameters.coh_fac / num)\n        sep_force *=  model.parameters.sep_fac\n        boid.vel  += (coh_force + sep_force) + aln_force\n        boid.vel  /= (veclength(boid.vel)+ep)\n        boid.orientation = calculate_direction(boid.vel)\n        boid.pos += boid.vel*dt\n    end\nend\n\nrun_model!(model, steps=500, step_rule = step_rule!)","category":"page"},{"location":"boids/#Step-4:-Visualisation","page":"Flocking 2D","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"In order to draw the model at a specific frame, say 4th, one can use draw_frame(model, frame = 4 ). If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"animate_sim(model)","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"(Image: png)","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[(:min_dis, \"slider\", 0.01:0.1:1.0),\n        (:coh_fac, \"slider\", 0.01:0.01:1.0),\n        (:sep_fac, \"slider\", 0.01:0.01:1.0),\n        (:aln_fac, \"slider\", 0.01:0.01:1.0),\n        (:vis_range, \"slider\", 0.5:0.5:4.0)], frames=400) ","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"(Image: png)","category":"page"},{"location":"boids/#Step-5:-Fetch-Data","page":"Flocking 2D","title":"Step 5: Fetch Data","text":"","category":"section"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"It is easy to fetch any data recorded during simulation. For example, the data of average velocity of agents at each time step can be obtained as - ","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"df = get_agents_avg_props(model, agent -> agent.vel, labels = [\"average velocity\"])","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"boids/#References","page":"Flocking 2D","title":"References","text":"","category":"section"},{"location":"boids/","page":"Flocking 2D","title":"Flocking 2D","text":"https://en.wikipedia.org/wiki/Flocking","category":"page"},{"location":"stone_paper_scissor/#Rock-Paper-Scissor","page":"Rock-Paper-Scissor","title":"Rock Paper Scissor","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"using EasyABM","category":"page"},{"location":"stone_paper_scissor/#Step-1:-Create-Model","page":"Rock-Paper-Scissor","title":"Step 1: Create Model","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"In this model, we work with patches instead of agents. We set grid_size to (50,50), set space_type to Periodic and define an additional model parameter threshold whose value is set to 3. ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"model = create_2d_model(size = (50,50), space_type = Periodic, threshold = 3)","category":"page"},{"location":"stone_paper_scissor/#Step-2:-Initialise-the-model","page":"Rock-Paper-Scissor","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"In the second step we initialise the patches by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we randomly assign cl\"red\" (for stone), cl\"green\" (for paper) and cl\"blue\" (for scissor) color to patches. Then we initialise the model using init_model! function, in which through the argument props_to_record, we tell EasyABM to record the :color property of patches during time evolution. Note that, in EasyABM animations are created with the recorded data, therefore if in the present model, the color of patches is not recorded there will be no animation to see. ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"function initialiser!(model)\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            num = rand()\n            if num<0.33\n                model.patches[i,j].color = cl\"red\" # stone => red, paper => green, scissor => blue\n            elseif num>0.66\n                model.patches[i,j].color = cl\"green\"\n            else\n                model.patches[i,j].color = cl\"blue\"\n            end\n        end\n    end\nend\n\ninit_model!(model, initialiser = initialiser!, props_to_record = Dict(\"patches\" => Set([:color])))","category":"page"},{"location":"stone_paper_scissor/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Rock-Paper-Scissor","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"In this step we define the step_rule! function and run the model for 400 steps. The rule of the game is very simple. The cl\"red\" color of a patch will change to cl\"green\" if number of neighboring patches with color cl\"green\" exceeds the threshold( which we set to be 3 in the beginning). Similarly, if a cl\"green\" patch finds larger than the threshold number of cl\"blue\" patches in its neighborhood, it will change to cl\"blue\", and if a cl\"blue\" patch finds larger than threshold number of cl\"red\" patches in its neighborhood it will change to cl\"red\". Each step of the model consists of 500 Monte-Carlo steps in which a patch is selected at random and the above mentioned rule applied to it. ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"const who_wins_against = Dict(cl\"red\" => cl\"green\", cl\"green\" => cl\"blue\", cl\"blue\" => cl\"red\")\n\nfunction step_rule!(model)\n    for _ in 1:500\n        i = rand(1:model.size[1])\n        j = rand(1:model.size[2])\n        nbr_patches = neighbor_patches_moore((i,j), model, 1)\n        col = model.patches[i,j].color\n        winner_col = who_wins_against[col]\n        count = 0 \n        for patch in nbr_patches\n            if model.patches[patch...].color == winner_col\n                count+=1\n            end\n        end\n        if count > model.parameters.threshold\n            model.patches[i,j].color = winner_col\n        end\n    end\nend\n\nrun_model!(model, steps = 400, step_rule = step_rule!)","category":"page"},{"location":"stone_paper_scissor/#Step-4:-Visualisation","page":"Rock-Paper-Scissor","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"In order to draw the model at a specific frame, say 4th, one can use draw_frame(model, frame = 4, show_patches=true). If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"animate_sim(model, show_patches=true) #since there are only patches and no agents, show_patches must be true for the animation","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"(Image: png)","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"create_interactive_app(model, initialiser= initialiser!,\n    props_to_record = Dict(\"patches\" => Set([:color])),\n    step_rule= step_rule!,\n    model_controls=[(:threshold, \"slider\", 1:8)], \n    frames=400, show_patches=true) ","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"(Image: png)","category":"page"},{"location":"stone_paper_scissor/#Step-5:-Fetch-Data","page":"Rock-Paper-Scissor","title":"Step 5: Fetch Data","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"It is easy to fetch any recorded data after running the model. For example, the numbers of different colored patches at all timesteps can be got as follows","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"df = get_nums_patches(model, \n    patch-> patch.color ==cl\"red\", \n    patch-> patch.color ==cl\"green\", \n    patch-> patch.color ==cl\"blue\", labels=[\"rock\",\"paper\",\"scissor\"], plot_result=true)","category":"page"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"(Image: png)","category":"page"},{"location":"stone_paper_scissor/#References","page":"Rock-Paper-Scissor","title":"References","text":"","category":"section"},{"location":"stone_paper_scissor/","page":"Rock-Paper-Scissor","title":"Rock-Paper-Scissor","text":"1.) https://twotwelve.uk/blog/rock-paper-scissors/","category":"page"},{"location":"boids3d/#Flocking-3D","page":"Flocking 3D","title":"Flocking 3D","text":"","category":"section"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"using EasyABM","category":"page"},{"location":"boids3d/#Step-1:-Create-Agents-and-Model","page":"Flocking 3D","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"Lets create 200 agents with properties shape, pos, vel and orientation (The orientation property is used internally by EasyABM to draw the direction agent is facing). The position pos is only accepted as a Vect which is an inbuilt vector type in EasyABM. It is also recommended for both convenience as well as performance to use Vect type for any vectorial properties in the model such as velocity and forces. The keeps_record_of argument is set of properties that an agent will record during time evolution. The model is defined with parameters:","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"min_dis : The distance between boids below which they start repelling each other.\ncoh_fac : The proportionality constant for the cohere force. \nsep_fac : The proportionality constant for the separation force.\naln_fac : The proportionality constant for the alignment force.\nvis_range : The visual range of boids.\ndt : The proportionality constant between change in position and velocity.","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"The argument agents_type is Static which means that the agents number will remain fixed during simulation. ","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"boids = con_3d_agents(200, shape = :cone, pos = Vect(0.0,0.0,0.0), \n    vel=Vect(0.0,0.0,0.0), orientation = Vect(0.0,0.0,0.0), keeps_record_of = Set([:pos, :orientation]))\nmodel = create_3d_model(boids, agents_type=Static, \n    space_type = Periodic, min_dis = 0.3, coh_fac = 0.05, \n    sep_fac = 0.5, dt= 0.1, vis_range = 2.0, aln_fac = 0.35)","category":"page"},{"location":"boids3d/#Step-2:-Initialise-the-model","page":"Flocking 3D","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"In this step we set the positions, velocities and orientations of boids and initialise the model.","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"function initialiser!(model)\n    xdim, ydim, zdim = model.size\n    for boid in model.agents\n        boid.pos = Vect(rand()*xdim, rand()*ydim, rand()*zdim)\n        boid.vel = Vect(1-2*rand(), 1-2*rand(), 1-2*rand())\n        boid.vel /= veclength(boid.vel)\n        boid.orientation = boid.vel\n    end\nend\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"boids3d/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Flocking 3D","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"In this step we implement the step logic of the flocking model in the step_rule! function and run the model for 500 steps. ","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"\nconst ep = 0.00001 # to avoid division by zero\n\nfunction step_rule!(model)\n    dt = model.parameters.dt\n    for boid in model.agents\n        nbrs = neighbors(boid, model, model.parameters.vis_range)\n        coh_force = Vect(0.0,0.0,0.0) \n        sep_force = Vect(0.0,0.0,0.0) \n        aln_force = Vect(0.0,0.0,0.0)\n        num = 0\n        for nbr in nbrs\n            num+=1\n            vec = nbr.pos - boid.pos\n            coh_force += vec\n            if veclength(vec)< model.parameters.min_dis\n                sep_force -= vec\n            end\n            aln_force += nbr.vel\n        end\n        aln_force = num>0 ? (aln_force / num - boid.vel) * model.parameters.aln_fac : aln_force\n        num = max(1, num)\n        coh_force *= (model.parameters.coh_fac/num)\n        sep_force *=  model.parameters.sep_fac\n        boid.vel  += (coh_force + sep_force) + aln_force\n        boid.vel  /= (veclength(boid.vel) + ep)\n        boid.orientation = boid.vel\n        boid.pos += boid.vel*dt\n    end\nend\n\nrun_model!(model, steps=500, step_rule = step_rule!)","category":"page"},{"location":"boids3d/#Step-4:-Visualisation","page":"Flocking 3D","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"The following code will draw the state of the model at frame number 4. ","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"draw_frame(model, frame=4)","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"animate_sim(model)","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"(Image: png)","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[(:min_dis, \"slider\", 0.01:0.1:1.0),\n        (:coh_fac, \"slider\", 0.01:0.01:1.0),\n        (:sep_fac, \"slider\", 0.01:0.01:1.0),\n        (:aln_fac, \"slider\", 0.01:0.01:1.0),\n        (:vis_range, \"slider\", 0.5:0.5:4.0)], frames=400) ","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"(Image: png)","category":"page"},{"location":"boids3d/#Step-5:-Fetch-Data","page":"Flocking 3D","title":"Step 5: Fetch Data","text":"","category":"section"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"It is easy to fetch any data recorded during simulation. For example, the data of average velocity of agents at each time step can be obtained as - ","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"df = get_agents_avg_props(model, agent -> agent.vel, labels = [\"average velocity\"])","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"boids3d/#References","page":"Flocking 3D","title":"References","text":"","category":"section"},{"location":"boids3d/","page":"Flocking 3D","title":"Flocking 3D","text":"1.) https://en.wikipedia.org/wiki/Flocking","category":"page"},{"location":"schelling3d/#Schelling-segregation-model","page":"Schellings Segregation 3D","title":"Schelling segregation model","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"using EasyABM","category":"page"},{"location":"schelling3d/#Step-1:-Create-Agents-and-Model","page":"Schellings Segregation 3D","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"Lets create 200 agents with properties pos, mood and color. The keeps_record_of argument is list of properties that the agent will record during time evolution. The min_alike property of the model which specifies the minimum number of alike neighbors for an agent to be happy, is set to be 8. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"@enum agentsfeeling happy sad\nagents = grid_3d_agents(200, pos = Vect(1,1,1), color = cl\"red\", mood = happy, keeps_record_of=Set([:pos, :mood]))\nmodel = create_3d_model(agents, agents_type = Static, space_type = NPeriodic, size = (7,7,7), min_alike = 8)","category":"page"},{"location":"schelling3d/#Step-2:-Initialise-the-model","page":"Schellings Segregation 3D","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"In the second step we initialise the agents by defining initialiser! function and then sending it as an argument to init_model!. In the initialiser! function we randomly set agents color to be either cl\"red\" or cl\"green\" and set their positions randomly such that there is not more than one agent on each patch. Then we set the mood property of each agent to be happy or sad depending upon the number of alike agents in neighborhood. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"function initialiser!(model)\n    for agent in model.agents\n        agent.color = [cl\"red\", cl\"green\"][rand(1:2)]\n        x,y,z = random_empty_patch(model) \n        agent.pos = Vect(x, y, z)     \n    end    \n    for agent in model.agents\n        nbrs = neighbors_moore(agent, model, 1)\n        num_same = 0\n        for nbr in nbrs\n            if nbr.color == agent.color\n                num_same += 1\n            end\n        end\n        if num_same < model.parameters.min_alike\n            agent.mood = sad\n        end\n    end\nend\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"schelling3d/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Schellings Segregation 3D","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"In this step we implement the step logic of the Schelling's model in the step_rule! function and run the model for 200 steps. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"function step_rule!(model)\n    min_alike = model.parameters.min_alike\n    for agent in model.agents\n        num_alike = 0\n        for nbr in neighbors_moore(agent, model,1)\n            if agent.color == nbr.color\n                num_alike += 1\n            end\n        end\n        if num_alike ≥ min_alike\n            agent.mood = happy\n        else\n            agent.mood = sad\n            x,y,z = random_empty_patch(model) \n            agent.pos = Vect(x, y, z)\n        end\n    end\n    return\nend\n\nrun_model!(model, steps=200, step_rule = step_rule!)","category":"page"},{"location":"schelling3d/#Step-4:-Visualisation","page":"Schellings Segregation 3D","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"The following code will draw the state of the model at frame number 4. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"draw_frame(model, frame=4)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"animate_sim(model)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"(Image: png)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule=step_rule!,\n    model_controls=[(:min_alike, \"slider\", 1:12)], \n    agent_plots=Dict(\n        \"happy\"=> agent-> agent.mood == happy, \n        \"sad\"=> agent-> agent.mood == sad),\n    frames=200)  \n","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"(Image: png)","category":"page"},{"location":"schelling3d/#Step-5:-Fetch-Data","page":"Schellings Segregation 3D","title":"Step 5: Fetch Data","text":"","category":"section"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"In this step we fetch data of number of happy and sad agents at each time step as a dataframe with following function. ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"df = get_nums_agents(model, agent-> agent.mood == happy, agent-> agent.mood == sad,labels=[\"happy\",\"sad\"], plot_result=true)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"(Image: png)","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"Individual agent data recorded during model run can be obtained as ","category":"page"},{"location":"schelling3d/","page":"Schellings Segregation 3D","title":"Schellings Segregation 3D","text":"df = get_agent_data(model.agents[1], model).record","category":"page"},{"location":"simple_pendulum/#Simple-pendulum","page":"Simple Pendulum","title":"Simple pendulum","text":"","category":"section"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"We will implement simulation of a simple pendulum using using graph space model.  ","category":"page"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"using EasyABM","category":"page"},{"location":"simple_pendulum/#Step-1:-Create-Model","page":"Simple Pendulum","title":"Step 1: Create Model","text":"","category":"section"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"In this model we will work solely with the graph and won't need agents. We initially create a graph with two nodes, and then create our model with parameters gravity, dt, len and in_angle as follows. ","category":"page"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"graph = graph_from_dict(Dict(\n    \"num_nodes\"=>2,\n    \"edges\"=>[(1,2)]\n))\n\nmodel = create_graph_model(gr, gravity = 9.0, dt=0.1, len= 4.0, in_angle=30.0)","category":"page"},{"location":"simple_pendulum/#Step-2:-Initialise-the-model","page":"Simple Pendulum","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"In this step set initial values of position, angle and angular velocity. The nodes in a graph can have values of x and y coordinates in range 0 to 10. We set the position of first (fixed) node to be Vect(5, 8) and that of the second node (which represents the hanging mass) at a distance of model.parameters.len and angle (in degrees) of model.parameters.in_angle below the fixed node. ","category":"page"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"function initialiser!(model)\n    len = model.parameters.len\n    theta = model.parameters.in_angle*pi/180\n    pos1 = Vect(5.0, 8.0)\n    pos2 = pos1 + Vect(len*sin(theta), -len*cos(theta))\n    model.graph.nodesprops[1].pos = pos1\n    model.graph.nodesprops[1].size = 0.1 # make the peg node small\n    model.graph.nodesprops[2].pos = pos2\n    model.graph.nodesprops[2].ang_vel = 0.0\n    model.graph.nodesprops[2].angle = theta\n    model.graph.nodesprops[2].color = cl\"blue\"\nend\n\ninit_model!(model, initialiser= initialiser!, \n    props_to_record = Dict(\"nodes\"=>Set([:pos]))) ","category":"page"},{"location":"simple_pendulum/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Simple Pendulum","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"In this step we implement the step logic of the simple pendulum and run the model for 500 steps. ","category":"page"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"function step_rule!(model)\n    len = model.parameters.len\n    dt = model.parameters.dt\n    gravity = model.parameters.gravity\n    peg = model.graph.nodesprops[1].pos\n    model.graph.nodesprops[2].angle += model.graph.nodesprops[2].ang_vel*dt\n    theta =  model.graph.nodesprops[2].angle\n    model.graph.nodesprops[2].ang_vel += -gravity*sin(theta)*dt/len\n    model.graph.nodesprops[2].pos = peg + Vect(len*sin(theta), -len*cos(theta))    \nend","category":"page"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"run_model!(model, steps = 500, step_rule = step_rule!)","category":"page"},{"location":"simple_pendulum/#Step-4:-Visualisation","page":"Simple Pendulum","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"animate_sim(model)","category":"page"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"(Image: png)","category":"page"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"create_interactive_app(model, initialiser= initialiser!,\n    props_to_record = Dict(\"nodes\"=>Set([:pos])),\n    step_rule= step_rule!,\n    model_controls=[(:len, \"slider\", 2.0:0.05:5.0), \n        (:in_angle, \"slider\", 5.0:0.1:75.0),\n        (:gravity, \"slider\", 1.0:0.5:20.0)],\n    frames=500) ","category":"page"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"(Image: png)","category":"page"},{"location":"simple_pendulum/#Step-4:-Fetch-Data","page":"Simple Pendulum","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"We can fetch the recorded data of the moving node (which is node 2 in our case) as follows","category":"page"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"df = get_node_data(2, model)","category":"page"},{"location":"simple_pendulum/","page":"Simple Pendulum","title":"Simple Pendulum","text":"```julia","category":"page"},{"location":"ising/#Ising-model","page":"Ising on a grid graph","title":"Ising model","text":"","category":"section"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"We use Ising model as an example of using Graph Models in EasyABM. We will set up and run Ising model on a grid graph, however one can choose graph of any other topology as well.","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"using EasyABM","category":"page"},{"location":"ising/#Step-1:-Create-Model","page":"Ising on a grid graph","title":"Step 1: Create Model","text":"","category":"section"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"In this model we will work solely with the graph and won't require agents. We create a grid graph of size 20x20, and then create our graph model as follows. ","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"graph = square_grid_graph(20,20); \nmodel = create_graph_model(graph, temp = 0.1, coupl = 1.0)","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"The model has two parameters temperature temp and coupling coupl. ","category":"page"},{"location":"ising/#Step-2:-Initialise-the-model","page":"Ising on a grid graph","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"In the second step we initialise the nodes of the graph through initialiser! function and then sending it as an argument to init_model!. In the initialiser! function we randomly set each node's color to either cl\"black\" or cl\"white\" and set their spin values to +1 for cl\"black\" nodes and -1 for cl\"white\" nodes. In the init_model! function the argument props_to_record specifies the nodes properties which we want to record during model run. ","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"function initialiser!(model)\n    for node in vertices(model.graph)\n        if rand()<0.5\n            model.graph.nodesprops[node].spin = 1\n            model.graph.nodesprops[node].color = cl\"black\"\n        else\n            model.graph.nodesprops[node].spin = -1\n            model.graph.nodesprops[node].color = cl\"white\"\n        end\n    end\nend\n\ninit_model!(model, initialiser = initialiser!, props_to_record = Dict(\"nodes\"=>Set([:color, :spin])))","category":"page"},{"location":"ising/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Ising on a grid graph","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"In this step we implement the step logic of the Ising model in the step_rule! function and run the model for 200 steps. At each step of the simulation we take  100 Monte Carlo steps, where in each Monte Carlo step a node is selected at random and its spin and color values are flipped if the Ising energy condition is satisfied. ","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"const nn = num_nodes(model) \n\nfunction step_rule!(model)\n    for i in 1:100\n        random_node = rand(1:nn)\n        spin = model.graph.nodesprops[random_node].spin\n        nbr_nodes = neighbor_nodes(random_node, model)\n        de = 0.0\n        for node in nbr_nodes\n            nbr_spin = model.graph.nodesprops[node].spin\n            de += spin*nbr_spin\n        end\n        de = 2*model.parameters.coupl * de\n        if (de < 0) || (rand() < exp(-de/model.parameters.temp))\n            model.graph.nodesprops[random_node].spin = - spin\n            model.graph.nodesprops[random_node].color = spin == -1 ? cl\"black\" : cl\"white\"\n        end\n    end\nend\n\nrun_model!(model, steps=200, step_rule = step_rule! )","category":"page"},{"location":"ising/#Step-4:-Visualisation","page":"Ising on a grid graph","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"In order to draw the model at a specific frame, say 4th, one can use draw_frame(model, frame = 4). If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"animate_sim(model)","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"(Image: png)","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"Note that the scale slider is for changing the size of agents. As we have zero agents in the current model, this slider won't do anything. ","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"create_interactive_app(model, initialiser= initialiser!,\n    props_to_record = Dict(\"nodes\"=>Set([:color, :spin])),\n    step_rule= step_rule!,\n    model_controls=[(:temp, \"slider\", 0.05:0.05:5), (:coupl, \"slider\", 0.01:0.1:5)],\n    node_plots = Dict(\"magnetisation\"=> x -> x.spin),\n    frames=200) ","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"(Image: png)","category":"page"},{"location":"ising/#Step-5:-Fetch-Data","page":"Ising on a grid graph","title":"Step 5: Fetch Data","text":"","category":"section"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"In this step we fetch the data of average spin of nodes (also called magnetisation) and plot the result as follows. ","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"df = get_nodes_avg_props(model, node -> node.spin, labels=[\"magnetisation\"], plot_result = true)","category":"page"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"(Image: png)","category":"page"},{"location":"ising/#References","page":"Ising on a grid graph","title":"References","text":"","category":"section"},{"location":"ising/","page":"Ising on a grid graph","title":"Ising on a grid graph","text":"https://en.wikipedia.org/wiki/Ising_model","category":"page"},{"location":"BrownianParticle/#Brownian-Particle","page":"Brownian Particle","title":"Brownian Particle","text":"","category":"section"},{"location":"BrownianParticle/","page":"Brownian Particle","title":"Brownian Particle","text":"using EasyABM","category":"page"},{"location":"BrownianParticle/#Step-1:-Create-Agents-and-Model","page":"Brownian Particle","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"BrownianParticle/","page":"Brownian Particle","title":"Brownian Particle","text":"balls = con_2d_agents(1000, pos = Vect(0.0,0.0), size = 0.05,mass=1.0,  \nkeeps_record_of = Set([:pos]))\nbox = con_2d_agent(pos=Vect(5.0,5.0), shape = :square_line, size = 10.0)\nmodel = create_2d_model([box, balls...], agents_type=Static, space_type = NPeriodic, dw =0.1)","category":"page"},{"location":"BrownianParticle/#Step-2:-Initialise-the-model","page":"Brownian Particle","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"BrownianParticle/","page":"Brownian Particle","title":"Brownian Particle","text":"function initialiser!(model)\n    xdim, ydim = model.size\n    #medium\n    for i in 3:length(model.agents)\n        agent=model.agents[i]\n        agent.pos = Vect(rand()*xdim, rand()*ydim)\n        v = Vect(rand()-0.5, rand()-0.5) \n        agent.vel = v/(veclength(v)+0.001)\n        agent.last_pos = agent.pos\n    end\n    \n    #brownian particle\n    model.agents[2].size = 0.15 #\n    model.agents[2].color = cl\"blue\"\n    model.agents[2].pos = Vect(5.0,5.0)\n    model.agents[2].vel = Vect(0.0,0.0)\n    model.agents[2].mass = 10.0\n    \nend\n\n\ninit_model!(model, initialiser=initialiser!)","category":"page"},{"location":"BrownianParticle/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Brownian Particle","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"BrownianParticle/","page":"Brownian Particle","title":"Brownian Particle","text":"\nfunction components(vec1, dir)\n    val = dotprod(vec1, dir)\n    vec_parl = dir*val\n    vec_perp = vec1-vec_parl\n    return vec_parl, vec_perp   \nend\n\nfunction transfer_momentum(agent, nbrs)\n    for nbr in nbrs\n        dir = nbr.pos - agent.pos\n        dist = veclength(dir)\n        if (nbr.shape == :circle) && (dist < agent.size+nbr.size)\n            unit_dir = dir/dist\n            mag = (agent.size+nbr.size) - dist\n            disp = unit_dir*mag*0.5\n            agent.pos -= disp\n            nbr.pos += disp\n            ag_vel_parl, ag_vel_perp = components(agent.vel, unit_dir)\n            nbr_vel_parl, nbr_vel_perp = components(nbr.vel, unit_dir)\n            x = nbr.mass/agent.mass\n            agent.vel = ag_vel_perp + (2*x*nbr_vel_parl+(1-x)*ag_vel_parl)/(1+x)\n            nbr.vel = nbr_vel_perp + (2*ag_vel_parl+(x-1)*nbr_vel_parl)/(1+x)\n        end\n    end\nend\n\nfunction reflect_from_boundaries(agent,xdim,ydim,dw)\n    x,y=agent.pos\n    velx, vely = agent.vel\n    if (x< dw) && (velx <0)\n        velx =-velx\n    end\n    if (x> xdim - dw) && (velx > 0)\n        velx =-velx\n    end\n    if (y< dw) && (vely <0)\n        vely =-vely\n    end\n    if (y> ydim- dw) && (vely > 0)\n        vely =-vely\n    end\n    agent.vel = Vect(velx, vely)\nend\n\nfunction step_rule!(model)\n    xdim, ydim = model.size\n    dw = model.parameters.dw\n    search_radius = model.agents[2].size # radius of the Brownian particle\n    for i in 2:length(model.agents)\n        agent=model.agents[i]\n        reflect_from_boundaries(agent,xdim, ydim, dw)\n        nbrs = neighbors(agent, model, search_radius)\n        transfer_momentum(agent, nbrs)\n        agent.pos += agent.vel*0.1\n    end\nend\n\nrun_model!(model, steps=200, step_rule = step_rule!)","category":"page"},{"location":"BrownianParticle/#Step-4:-Visualisation","page":"Brownian Particle","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"BrownianParticle/","page":"Brownian Particle","title":"Brownian Particle","text":"animate_sim(model)","category":"page"},{"location":"BrownianParticle/","page":"Brownian Particle","title":"Brownian Particle","text":"(Image: png)","category":"page"},{"location":"BrownianParticle/#References","page":"Brownian Particle","title":"References","text":"","category":"section"},{"location":"BrownianParticle/","page":"Brownian Particle","title":"Brownian Particle","text":"https://en.wikipedia.org/wiki/Brownian_motion","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = EasyABM","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warn: Warn\nThis documentation is for the upcoming version 2.0.0 of EasyABM which has some breaking changes.  ","category":"page"},{"location":"#EasyABM.jl","page":"Introduction","title":"EasyABM.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A lightweight and easy to use framework for agent-based modelling. ","category":"page"},{"location":"#Package-Features","page":"Introduction","title":"Package Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Intuitive function based approach for all ABM modelling tasks. \nSupport for Heterogeneous agents, where each agent can record its own properties. \nGrid blocks, called patches, in 2d and 3d models can be assigned properties like agents.\nNodes and edges in a graph based model can also be assigned properties like agents. \nUnderlying Graph in a graph model can be chosen to be fully dynamic in which edges and nodes can be added or removed during model run.\nEasy to create and save animation.\nLive interactive panel can also be easily created in Jupyter in a few lines of code. ","category":"page"},{"location":"conwaygol/#Conway's-Game-of-Life","page":"Conways Game of Life","title":"Conway's Game of Life","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"using EasyABM","category":"page"},{"location":"conwaygol/#Step-1:-Create-Agents-and-Model","page":"Conways Game of Life","title":"Step 1: Create Agents and Model","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"We work with only patches in this model. The size of the  grid in the model created is 20x20 and alive_percent is the fraction of patches that are alive initially.","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"model = create_2d_model(size = (20,20), alive_percent = 0.4)","category":"page"},{"location":"conwaygol/#Step-2:-Initialise-the-model","page":"Conways Game of Life","title":"Step 2: Initialise the model","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"In the second step we initialise the patches by defining initialiser! function and sending it as an argument to init_model!. In the initialiser! function we randomly set patches to be either of color cl\"green\" or cl\"white\" (a named color, say \"green\", can be defined in EasyABM as cl\"green\" or as Col(\"green\") or more generally as Col(0,1,0) or Col(0,1,0,1)). The patches with green color have their is_alive property set to true and the patches with white color have their is_alive property set to false. We specify the patch properties color and is_alive that we want to be recorded during time evolution in the props_to_record argument to the init_model! function.","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"function initialiser!(model)\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            if rand()<model.parameters.alive_percent\n                model.patches[i,j].color = cl\"green\"\n                model.patches[i,j].is_alive = true\n            else\n                model.patches[i,j].color = cl\"white\"\n                model.patches[i,j].is_alive = false\n            end\n        end\n    end\nend\n\ninit_model!(model, initialiser = initialiser!, \n    props_to_record=Dict(\"patches\"=>Set([:color, :is_alive])))","category":"page"},{"location":"conwaygol/#Step-3:-Defining-the-step_rule!-and-running-the-model","page":"Conways Game of Life","title":"Step 3: Defining the step_rule! and running the model","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"In this step we implement the step logic of the Conway's Game of Life in the step_rule! function and run the model for 100 steps.  Since Conway's model requires all patches to be updated at the same time, in the step_rule! function we first compute the is_alive  property for all patches and then apply it to patches.","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"function calculate_vals(model)\n    vals = [false for i in 1:model.size[1], j in 1:model.size[2]]\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            patch = model.patches[i,j]\n            nbrs = neighbor_patches_moore((i,j), model, 1)\n            num_alive = 0\n            for nbr in nbrs\n                num_alive+= model.patches[nbr...].is_alive\n            end\n            condition1 = patch.is_alive && ((num_alive == 2) || (num_alive == 3))\n            condition2 = !(patch.is_alive) && (num_alive == 3)\n            if condition1 || condition2\n                vals[i,j] = true\n            end\n        end\n    end\n    return vals\nend\n\nfunction apply_vals!(model, vals)\n    for j in 1:model.size[2]\n        for i in 1:model.size[1]\n            is_alive = vals[i,j]\n            model.patches[i,j].is_alive = is_alive\n            model.patches[i,j].color = is_alive ? cl\"green\" : cl\"white\"\n        end\n    end       \nend\n\n\nfunction step_rule!(model)\n    vals = calculate_vals(model)\n    apply_vals!(model, vals)\nend\n\nrun_model!(model, steps=100, step_rule = step_rule! )","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"In order to draw the model at a specific frame, say 4th, one can use draw_frame(model, frame = 4, show_patches=true). If one wants to see the animation of the model run, it can be done as ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"animate_sim(model, show_patches=true)","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"(Image: png)","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"After defining the step_rule! function we can also choose to create an interactive application (which currently works in Jupyter with WebIO installation) as ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"create_interactive_app(model, initialiser= initialiser!,\n    props_to_record=Dict(\"patches\"=>Set([:color, :is_alive])),\n    step_rule= step_rule!,\n    model_controls=[\n        (:alive_percent, \"slider\", 0:0.01:1.0)\n        ], \n    frames=200, show_patches=true) ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"(Image: png)","category":"page"},{"location":"conwaygol/#Step-4:-Fetch-Data","page":"Conways Game of Life","title":"Step 4: Fetch Data","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"We can fetch the data of number alive patches as follows. ","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"df = get_nums_patches(model, patch-> patch.is_alive, labels=[\"Alive\"], \n    plot_result = true)","category":"page"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"(Image: png)","category":"page"},{"location":"conwaygol/#References","page":"Conways Game of Life","title":"References","text":"","category":"section"},{"location":"conwaygol/","page":"Conways Game of Life","title":"Conways Game of Life","text":"https://en.wikipedia.org/wiki/Conway%27sGameof_Life","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Studying an agents based model in EasyABM is basically a 5-step process. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create agents and model. \nInitialise the model, using the init_model! function.\nDefine a step_rule function and run the model. \nVisualisation which can be achieved simply by running animate_sim(model). One can alo explore the model through an interactive app that can be created using the function create_interactive_app. \nFetch and analyse data collected during model run. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We explain these steps below through a very simple model of a star-planet system. Though it can be debated if a star-planet system can really qualify as an agent based model, it nevertheless serves as a good example for demonstrating the workings of EasyABM. ","category":"page"},{"location":"tutorial/#Step-1:-Create-the-agents-and-the-model.","page":"Tutorial","title":"Step 1: Create the agents and the model.","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the first step we create the agents and the model. For the star-planet system, we need one agent for the star and one for the planet. We will assume that the star is stationary and the planet revolves around it. We set the position of the star to be Vect(5.0,5.0) which is the center point of the 2d space, as the default dimensions of 2d space in EasyABM is 10x10. The position pos is only accepted as a Vect which is an inbuilt vector type in EasyABM. It is also recommended for both convenience as well as performance to use Vect type for any vectorial properties in the model such as velocity and forces. We set the position of the planet to be Vect(7.0,5.0) and its velocity to be Vect(0.0,1.0). Since, the planet will change its position we require it to record its position and velocity during the model run. We specify this via keeps_record_of argument in the function for creating agent(s). We also have user defined model properties gravity and dt which stand for the force of gravity and small time interval between position and velocity updates respectively. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"star = con_2d_agent( pos = Vect(5.0,5.0), size = 0.15, color = cl\"yellow\") # by default 2d space is 10x10, so that (5,5) is center.\nplanet = con_2d_agent(pos = Vect(7.0,5.0), vel = Vect(0.0,1.0), size=0.05, color = cl\"blue\", keeps_record_of = Set([:pos, :vel])) \nmodel = create_2d_model([star, planet], gravity = 3.0, dt=0.1)","category":"page"},{"location":"tutorial/#Step-2:-Initialise-the-model.","page":"Tutorial","title":"Step 2: Initialise the model.","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this step we define an initialiser function to set the initial properties of the agents. Suppose we want our planet to be at position Vect(5.0,8.0) and velocity Vect(-1.0, 0.0) initially. We can do so by defining an initialiser function and then sending it as an argument to init_model! function as follows.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function initialiser!(model)\n    planet = model.agents[2]\n    planet.pos = Vect(5.0, 8.0)\n    planet.vel = Vect(-1.0,0.0)\nend\n\ninit_model!(model, initialiser = initialiser!)","category":"page"},{"location":"tutorial/#Step-3:-Define-a-step_rule-and-run-the-model","page":"Tutorial","title":"Step 3: Define a step_rule and run the model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this step, we define rule for the time evolution and then run the model. We define our step_rule to be simply discretisation of Newton's equations for a 2 body system.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function step_rule!(model)\n    gravity = model.parameters.gravity\n    dt = model.parameters.dt\n    star = model.agents[1]\n    planet = model.agents[2]\n    distance_vector = (star.pos - planet.pos)\n    distance = veclength(distance_vector)\n    force = gravity*distance_vector/distance^3\n    planet.vel += force*dt\n    planet.pos+= planet.vel*dt\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can run the model for desired number of steps as follows","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"run_model!(model, steps = 200, step_rule = step_rule!)","category":"page"},{"location":"tutorial/#Step-4:-Visualisation","page":"Tutorial","title":"Step 4: Visualisation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to draw the model at a specific frame, say 4th, one can use draw_frame(model, frame = 4). We can look at the animation of the time evolution with following line of code","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"animate_sim(model,tail = (30, agent -> agent.color == cl\"blue\")) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The tail argument attaches a tail of length 30 to the agent whose color is blue, which in our case is the planet. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: png)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The model can be saved to the disk as a jld2 file using following function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"save_model(model, model_name = \"sun_planet_model\", save_as = \"sun_planet.jld2\", folder = \"/path/to/folder/\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A model saved previously as jld2 file, can be fetched as follows ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"model = open_model(model_name = \"sun_planet_model\", path = \"/path/to/folder/sun_planet.jld2\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Instead of first running the model, we can create an interactive app in Jupyter notebook to explore the model by setting different values of parameters, as shown below. Here, the model_control argument asks EasyABM to create a slider with values from 1 to 5 in steps of 0.2 for the model parameter gravity. The agent_controls argument creates a slider for the x component of planet's initial velocity. The tail argument attaches a tail of length 30 with the planet by selecting it with its color property which we previously set to cl\"blue\". ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"create_interactive_app(model, initialiser= initialiser!,\n    step_rule= step_rule!,\n    model_controls=[(:gravity, \"slider\", 1:0.2:5.0)], \n    agent_controls=[(:vel, \"slider\", [Vect(x, 0.0) for x in -10.0:0.1:5.0])],\n    frames=200, tail = (30, agent -> agent.color == cl\"blue\")) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: png)","category":"page"},{"location":"tutorial/#Step-5:-Fetch-data","page":"Tutorial","title":"Step 5: Fetch data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this simple model, the only data we have collected is the position and velocity of the planet. We can get this data as follows. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df = get_agent_data(model.agents[2], model).record","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The following line of code returns the data of (half of the) speed of the planet during time evolution.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df = get_agents_avg_props(model, agent -> agent.color == cl\"blue\" ? veclength(agent.vel) : 0.0, labels = [\"Planet Speed/2\"], plot_result = true)   ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: png)","category":"page"}]
}
